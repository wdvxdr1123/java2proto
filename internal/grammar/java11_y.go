//line grammar/java11.y:2

/*------------------------------------------------------------------
 * Massively hacked by Dave Glowacki <dave@glowacki.org> from the
 * original source by:
 *------------------------------------------------------------------
 * Copyright (C)
 *   1996, 1997, 1998 Dmitri Bronnikov, All rights reserved.
 *
 * THIS GRAMMAR IS PROVIDED "AS IS" WITHOUT  ANY  EXPRESS  OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES  OF  MERCHANTABILITY  AND  FITNESS  FOR  A  PARTICULAR
 * PURPOSE, OR NON-INFRINGMENT.
 *
 * Bronikov@inreach.com
 *
 *------------------------------------------------------------------
 *
 * VERSION 1.06 DATE 20 AUG 1998
 *
 *------------------------------------------------------------------
 *
 * UPDATES
 *
 * 1.06 Correction of Java 1.1 syntax
 * 1.05 Yet more Java 1.1
 *      <qualified name>.<allocation expression>
 * 1.04 More Java 1.1 features:
 *      <class name>.this
 *      <type name>.class
 * 1.03 Added Java 1.1 features:
 *      inner classes,
 *      anonymous classes,
 *      non-static initializer blocks,
 *      array initialization by new operator
 * 1.02 Corrected cast expression syntax
 * 1.01 All shift/reduce conflicts, except dangling else, resolved
 *
 *------------------------------------------------------------------
 *
 * PARSING CONFLICTS RESOLVED
 *
 * Some Shift/Reduce conflicts have been resolved at the expense of
 * the grammar defines a superset of the language. The following
 * actions have to be performed to complete program syntax checking:
 *
 * 1) Check that modifiers applied to a class, interface, field,
 *    or constructor are allowed in respectively a class, inteface,
 *    field or constructor declaration. For example, a class
 *    declaration should not allow other modifiers than abstract,
 *    final and public.
 *
 * 2) For an expression statement, check it is either increment, or
 *    decrement, or assignment expression.
 *
 * 3) Check that type expression in a cast operator indicates a type.
 *    Some of the compilers that I have tested will allow simultaneous
 *    use of identically named type and variable in the same scope
 *    depending on context.
 *
 * 4) Change lexical definition to change '[' optionally followed by
 *    any number of white-space characters immediately followed by ']'
 *    to OP_DIM token. I defined this token as [\[]{white_space}*[\]]
 *    in the lexer.
 *
 *------------------------------------------------------------------
 *
 * UNRESOLVED SHIFT/REDUCE CONFLICTS
 *
 * Dangling else in if-then-else
 *
 *------------------------------------------------------------------
 */

package grammar

import (
	"fmt"
	"runtime/debug"
)

//line grammar/java11.y:74

type tmpVariableId struct {
	object
	name string
	dims int
}

func ReportCastError(expName string, obj interface{}) {
	debug.PrintStack()
	panic(fmt.Sprintf("Expected %s, got %T (%s)", expName, obj, obj))
}

func ReportError(msg string) {
	debug.PrintStack()
	panic(msg)
}

func makeFormalParamList(objlist []JObject) []*JFormalParameter {
	if objlist == nil || len(objlist) == 0 {
		return nil
	}

	list := make([]*JFormalParameter, len(objlist))
	for i, obj := range objlist {
		if elem, ok := obj.(*JFormalParameter); !ok {
			ReportCastError("JFormalParameter", obj)
		} else {
			list[i] = elem
		}
	}

	return list
}

func makeVarDeclList(objlist []JObject) []*JVariableDecl {
	if objlist == nil || len(objlist) == 0 {
		return nil
	}

	list := make([]*JVariableDecl, len(objlist))
	for i, obj := range objlist {
		if elem, ok := obj.(*JVariableDecl); !ok {
			ReportCastError("JVariableDecl", obj)
		} else {
			list[i] = elem
		}
	}

	return list
}

//line grammar/java11.y:132
type JulySymType struct {
	yys      int
	token    int
	str      string
	name     *JTypeName
	namelist []*JTypeName
	obj      JObject
	objlist  []JObject
	count    int
	varlist  []*JVariableInit
}

const IDENTIFIER = 57346
const LITERAL = 57347
const BOOLLIT = 57348
const OP_EQ = 57349
const OP_NE = 57350
const OP_LOR = 57351
const OP_LAND = 57352
const OP_INC = 57353
const OP_DEC = 57354
const OP_SHL = 57355
const OP_SHRR = 57356
const ASS_ADD = 57357
const ASS_SUB = 57358
const ASS_MUL = 57359
const ASS_DIV = 57360
const ASS_AND = 57361
const ASS_OR = 57362
const ASS_XOR = 57363
const ASS_MOD = 57364
const OP_DIM = 57365
const ABSTRACT = 57366
const ASSERT = 57367
const BOOLEAN = 57368
const BREAK = 57369
const BYTE = 57370
const CASE = 57371
const CATCH = 57372
const CHAR = 57373
const CLASS = 57374
const CONTINUE = 57375
const DEFAULT = 57376
const DO = 57377
const DOUBLE = 57378
const ELSE = 57379
const ENUM = 57380
const EXTENDS = 57381
const FINAL = 57382
const FINALLY = 57383
const FLOAT = 57384
const FOR = 57385
const IF = 57386
const IMPLEMENTS = 57387
const IMPORT = 57388
const INSTANCEOF = 57389
const INT = 57390
const INTERFACE = 57391
const LONG = 57392
const NATIVE = 57393
const NEW = 57394
const JNULL = 57395
const PACKAGE = 57396
const PRIVATE = 57397
const PROTECTED = 57398
const PUBLIC = 57399
const RETURN = 57400
const SHORT = 57401
const STATIC = 57402
const SUPER = 57403
const SWITCH = 57404
const SYNCHRONIZED = 57405
const THIS = 57406
const THROW = 57407
const THROWS = 57408
const TRANSIENT = 57409
const TRY = 57410
const VOID = 57411
const VOLATILE = 57412
const WHILE = 57413

var JulyToknames = []string{
	"IDENTIFIER",
	"LITERAL",
	"BOOLLIT",
	"OP_EQ",
	"OP_NE",
	"OP_LOR",
	"OP_LAND",
	"OP_INC",
	"OP_DEC",
	"OP_SHL",
	"OP_SHRR",
	"ASS_ADD",
	"ASS_SUB",
	"ASS_MUL",
	"ASS_DIV",
	"ASS_AND",
	"ASS_OR",
	"ASS_XOR",
	"ASS_MOD",
	"OP_DIM",
	"ABSTRACT",
	"ASSERT",
	"BOOLEAN",
	"BREAK",
	"BYTE",
	"CASE",
	"CATCH",
	"CHAR",
	"CLASS",
	"CONTINUE",
	"DEFAULT",
	"DO",
	"DOUBLE",
	"ELSE",
	"ENUM",
	"EXTENDS",
	"FINAL",
	"FINALLY",
	"FLOAT",
	"FOR",
	"IF",
	"IMPLEMENTS",
	"IMPORT",
	"INSTANCEOF",
	"INT",
	"INTERFACE",
	"LONG",
	"NATIVE",
	"NEW",
	"JNULL",
	"PACKAGE",
	"PRIVATE",
	"PROTECTED",
	"PUBLIC",
	"RETURN",
	"SHORT",
	"STATIC",
	"SUPER",
	"SWITCH",
	"SYNCHRONIZED",
	"THIS",
	"THROW",
	"THROWS",
	"TRANSIENT",
	"TRY",
	"VOID",
	"VOLATILE",
	"WHILE",
}
var JulyStatenames = []string{}

const JulyEofCode = 1
const JulyErrCode = 2
const JulyMaxDepth = 200

//line grammar/java11.y:2636

//line yacctab:1
var JulyExca = []int{
	-1, 1,
	1, -1,
	-2, 0,
	-1, 3,
	1, 5,
	-2, 93,
	-1, 4,
	1, 7,
	-2, 93,
	-1, 5,
	1, 8,
	-2, 93,
	-1, 32,
	1, 3,
	-2, 93,
	-1, 33,
	1, 4,
	-2, 93,
	-1, 34,
	1, 6,
	-2, 93,
	-1, 48,
	1, 2,
	-2, 93,
	-1, 162,
	85, 210,
	-2, 93,
	-1, 169,
	85, 431,
	-2, 93,
	-1, 288,
	4, 190,
	26, 190,
	28, 190,
	31, 190,
	36, 190,
	42, 190,
	48, 190,
	50, 190,
	59, 190,
	-2, 88,
	-1, 289,
	4, 191,
	26, 191,
	28, 191,
	31, 191,
	36, 191,
	42, 191,
	48, 191,
	50, 191,
	59, 191,
	-2, 94,
	-1, 291,
	4, 58,
	-2, 366,
	-1, 298,
	85, 430,
	-2, 93,
	-1, 691,
	85, 210,
	-2, 93,
	-1, 720,
	32, 93,
	38, 93,
	49, 93,
	-2, 261,
}

const JulyNprod = 444
const JulyPrivate = 57344

var JulyTokenNames []string
var JulyStates []string

const JulyLast = 2631

var JulyAct = []int{

	366, 674, 364, 692, 265, 272, 85, 266, 225, 19,
	264, 405, 666, 478, 533, 690, 10, 526, 539, 527,
	226, 597, 483, 528, 658, 269, 406, 485, 46, 383,
	388, 540, 104, 374, 492, 101, 495, 152, 115, 18,
	311, 141, 569, 147, 20, 100, 13, 166, 12, 168,
	98, 232, 251, 270, 94, 93, 99, 97, 96, 86,
	65, 179, 95, 45, 631, 230, 78, 67, 88, 87,
	563, 150, 50, 233, 254, 461, 458, 254, 156, 448,
	237, 144, 254, 215, 216, 172, 204, 231, 202, 218,
	171, 252, 742, 731, 706, 693, 381, 254, 741, 198,
	694, 88, 87, 724, 222, 219, 220, 696, 652, 505,
	171, 443, 158, 54, 408, 561, 571, 693, 76, 161,
	186, 160, 694, 504, 73, 63, 562, 185, 162, 184,
	142, 253, 230, 135, 137, 233, 253, 133, 221, 480,
	233, 463, 320, 174, 175, 571, 375, 230, 536, 375,
	432, 718, 462, 321, 231, 233, 156, 162, 169, 162,
	165, 258, 21, 275, 234, 235, 236, 242, 46, 231,
	79, 167, 289, 689, 169, 156, 707, 707, 169, 268,
	299, 169, 21, 292, 254, 111, 254, 296, 257, 431,
	158, 429, 37, 318, 294, 40, 46, 161, 317, 160,
	88, 87, 244, 45, 480, 243, 322, 47, 69, 158,
	571, 480, 293, 295, 297, 80, 161, 186, 160, 262,
	647, 72, 162, 301, 185, 52, 184, 480, 312, 162,
	47, 45, 357, 571, 360, 314, 38, 313, 361, 305,
	303, 298, 70, 254, 630, 162, 544, 307, 71, 319,
	315, 381, 254, 335, 323, 79, 145, 149, 327, 121,
	334, 379, 325, 326, 324, 149, 275, 328, 233, 354,
	80, 72, 486, 401, 427, 289, 238, 162, 411, 71,
	403, 275, 268, 188, 71, 421, 423, 72, 394, 223,
	70, 377, 491, 425, 370, 371, 71, 389, 75, 386,
	80, 390, 172, 494, 156, 254, 414, 381, 21, 149,
	390, 736, 544, 381, 669, 337, 339, 605, 72, 558,
	254, 708, 46, 75, 557, 254, 604, 445, 69, 88,
	87, 148, 333, 672, 373, 72, 257, 332, 158, 148,
	428, 453, 430, 380, 145, 161, 633, 160, 291, 312,
	441, 613, 433, 331, 576, 399, 314, 45, 313, 330,
	556, 614, 575, 224, 191, 712, 390, 622, 381, 447,
	466, 381, 145, 581, 451, 240, 470, 460, 743, 610,
	494, 732, 399, 148, 338, 459, 695, 683, 632, 606,
	595, 593, 592, 590, 336, 479, 189, 145, 594, 49,
	487, 424, 233, 416, 413, 457, 469, 59, 412, 275,
	410, 503, 471, 506, 507, 206, 499, 519, 263, 194,
	146, 455, 290, 467, 477, 525, 487, 452, 211, 498,
	450, 446, 531, 248, 502, 389, 145, 487, 535, 145,
	454, 149, 254, 473, 484, 500, 263, 472, 145, 552,
	553, 291, 550, 701, 38, 49, 145, 300, 212, 213,
	143, 559, 710, 77, 468, 60, 560, 599, 551, 600,
	514, 263, 60, 542, 704, 588, 548, 500, 637, 618,
	38, 534, 564, 570, 572, 493, 554, 254, 555, 192,
	402, 568, 49, 145, 403, 255, 253, 582, 145, 493,
	176, 570, 501, 565, 500, 591, 579, 228, 229, 584,
	381, 254, 577, 263, 249, 148, 486, 580, 601, 489,
	190, 490, 263, 725, 403, 290, 21, 589, 543, 21,
	263, 586, 587, 69, 74, 609, 132, 240, 585, 271,
	173, 51, 62, 64, 403, 615, 607, 623, 685, 611,
	608, 612, 21, 480, 480, 639, 620, 616, 352, 677,
	621, 419, 626, 241, 634, 51, 53, 263, 629, 227,
	51, 49, 263, 480, 570, 578, 145, 624, 625, 627,
	713, 417, 542, 542, 641, 240, 487, 583, 702, 570,
	570, 275, 698, 682, 275, 649, 275, 642, 681, 638,
	654, 656, 291, 659, 660, 680, 678, 662, 163, 657,
	646, 636, 664, 145, 617, 603, 645, 663, 651, 648,
	487, 650, 524, 487, 535, 679, 643, 644, 670, 420,
	484, 668, 523, 676, 619, 608, 522, 671, 521, 409,
	61, 543, 51, 508, 66, 250, 474, 687, 570, 418,
	263, 38, 530, 697, 714, 738, 659, 145, 659, 145,
	145, 145, 659, 529, 665, 715, 574, 534, 475, 38,
	145, 640, 7, 709, 369, 403, 290, 35, 705, 381,
	699, 368, 700, 60, 254, 686, 703, 200, 275, 675,
	653, 38, 275, 68, 722, 721, 720, 726, 261, 659,
	145, 289, 728, 659, 719, 35, 407, 39, 268, 734,
	134, 356, 735, 717, 58, 737, 730, 208, 209, 716,
	145, 275, 739, 727, 88, 87, 306, 729, 401, 598,
	289, 123, 549, 263, 263, 263, 5, 268, 744, 745,
	33, 34, 546, 355, 263, 746, 545, 88, 87, 747,
	497, 329, 496, 456, 439, 26, 436, 393, 387, 136,
	138, 139, 145, 143, 353, 316, 81, 711, 60, 48,
	57, 27, 56, 55, 263, 4, 628, 309, 164, 32,
	372, 358, 28, 118, 363, 117, 24, 23, 22, 116,
	102, 155, 217, 384, 29, 38, 667, 214, 30, 145,
	8, 31, 396, 153, 210, 207, 36, 21, 740, 205,
	404, 203, 239, 201, 199, 162, 256, 131, 193, 124,
	91, 340, 126, 684, 520, 518, 516, 130, 245, 246,
	513, 247, 512, 129, 36, 36, 263, 511, 510, 127,
	691, 128, 532, 426, 509, 688, 267, 437, 464, 36,
	125, 667, 442, 365, 481, 547, 673, 541, 538, 274,
	119, 120, 183, 182, 181, 302, 105, 106, 177, 395,
	385, 392, 391, 159, 476, 157, 154, 291, 195, 89,
	277, 131, 282, 124, 84, 82, 126, 170, 283, 378,
	280, 130, 140, 733, 382, 187, 17, 129, 281, 276,
	16, 15, 14, 127, 573, 128, 291, 123, 114, 3,
	2, 1, 0, 284, 125, 0, 113, 278, 415, 112,
	285, 0, 0, 287, 122, 0, 279, 273, 0, 0,
	488, 26, 0, 0, 0, 0, 103, 0, 376, 162,
	0, 0, 0, 0, 109, 110, 0, 27, 107, 108,
	0, 290, 0, 0, 0, 0, 515, 0, 28, 0,
	0, 0, 24, 23, 22, 0, 0, 155, 0, 0,
	29, 0, 0, 0, 30, 0, 0, 31, 0, 153,
	290, 0, 0, 21, 0, 0, 0, 0, 0, 0,
	0, 162, 151, 0, 434, 435, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 274,
	119, 120, 0, 384, 566, 567, 105, 106, 0, 0,
	0, 0, 0, 0, 488, 0, 0, 0, 0, 26,
	277, 131, 282, 124, 693, 0, 126, 0, 283, 694,
	280, 130, 0, 0, 0, 288, 0, 129, 281, 276,
	0, 0, 0, 127, 596, 128, 28, 123, 114, 0,
	24, 23, 22, 284, 125, 25, 113, 278, 286, 112,
	285, 0, 30, 287, 122, 31, 279, 273, 0, 0,
	0, 21, 0, 0, 0, 0, 103, 0, 0, 162,
	0, 0, 0, 0, 109, 110, 0, 0, 107, 108,
	0, 274, 119, 120, 0, 0, 0, 0, 105, 106,
	0, 0, 0, 0, 0, 0, 488, 0, 0, 0,
	0, 26, 277, 131, 282, 124, 0, 537, 126, 0,
	283, 0, 280, 130, 0, 0, 0, 288, 0, 129,
	281, 276, 0, 0, 0, 127, 0, 128, 28, 123,
	114, 0, 24, 23, 22, 284, 125, 25, 113, 278,
	286, 112, 285, 0, 30, 287, 122, 31, 279, 273,
	0, 0, 0, 21, 0, 0, 0, 0, 103, 0,
	0, 162, 400, 0, 0, 0, 109, 110, 0, 0,
	107, 108, 274, 119, 120, 0, 0, 0, 0, 105,
	106, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 26, 277, 131, 282, 124, 0, 0, 126,
	0, 283, 0, 280, 130, 0, 0, 0, 288, 0,
	129, 281, 276, 0, 0, 0, 127, 0, 128, 28,
	123, 114, 0, 24, 23, 22, 284, 125, 25, 113,
	278, 286, 112, 285, 0, 30, 287, 122, 31, 279,
	273, 0, 0, 0, 21, 0, 38, 119, 120, 103,
	0, 0, 162, 105, 106, 0, 0, 109, 110, 0,
	0, 107, 108, 0, 38, 119, 120, 0, 131, 0,
	124, 105, 106, 126, 0, 0, 0, 0, 130, 0,
	0, 0, 0, 0, 129, 0, 131, 0, 124, 0,
	127, 126, 128, 0, 123, 114, 130, 0, 0, 0,
	0, 125, 129, 113, 0, 0, 112, 0, 127, 0,
	128, 122, 123, 114, 0, 0, 196, 0, 21, 125,
	0, 113, 0, 103, 112, 0, 92, 197, 0, 122,
	0, 109, 110, 0, 0, 107, 108, 38, 119, 120,
	0, 103, 359, 0, 105, 106, 0, 0, 0, 109,
	110, 0, 38, 107, 108, 0, 0, 0, 0, 131,
	0, 124, 0, 0, 126, 0, 0, 0, 0, 130,
	0, 0, 0, 486, 131, 129, 124, 0, 0, 126,
	0, 127, 0, 128, 130, 123, 114, 0, 486, 0,
	129, 0, 125, 0, 113, 0, 127, 112, 128, 0,
	0, 0, 122, 0, 0, 517, 0, 125, 0, 21,
	38, 119, 120, 0, 103, 0, 0, 105, 106, 0,
	0, 0, 109, 110, 21, 0, 107, 108, 38, 119,
	120, 0, 131, 0, 124, 105, 106, 126, 0, 0,
	0, 0, 130, 0, 0, 0, 0, 0, 129, 0,
	131, 0, 124, 0, 127, 126, 128, 0, 123, 114,
	130, 0, 0, 0, 0, 125, 129, 113, 0, 0,
	112, 0, 127, 0, 128, 122, 123, 114, 0, 0,
	0, 0, 21, 125, 0, 113, 0, 103, 112, 0,
	92, 444, 0, 122, 0, 109, 110, 0, 0, 107,
	108, 90, 119, 120, 0, 103, 0, 0, 105, 106,
	0, 0, 0, 109, 110, 0, 38, 107, 108, 0,
	0, 0, 0, 131, 0, 124, 0, 0, 126, 0,
	0, 0, 0, 130, 0, 0, 0, 0, 131, 129,
	124, 0, 0, 126, 0, 127, 0, 128, 130, 123,
	114, 0, 402, 0, 129, 0, 125, 0, 113, 0,
	127, 112, 128, 0, 0, 0, 122, 0, 0, 0,
	0, 125, 0, 21, 0, 38, 119, 120, 103, 83,
	0, 92, 105, 106, 0, 0, 109, 110, 21, 0,
	107, 108, 0, 38, 119, 120, 0, 131, 0, 124,
	105, 106, 126, 0, 0, 0, 0, 130, 0, 0,
	0, 0, 0, 129, 0, 131, 0, 124, 0, 127,
	126, 128, 0, 123, 114, 130, 0, 0, 0, 0,
	125, 129, 113, 0, 0, 112, 0, 127, 0, 128,
	122, 123, 114, 0, 0, 0, 0, 21, 125, 0,
	113, 0, 103, 112, 0, 92, 0, 0, 122, 0,
	109, 110, 0, 0, 107, 108, 0, 0, 0, 0,
	103, 0, 0, 367, 635, 0, 0, 0, 109, 110,
	0, 0, 107, 108, 38, 119, 120, 0, 0, 0,
	0, 105, 106, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 38, 119, 120, 0, 131, 0, 124, 105,
	106, 126, 0, 0, 0, 0, 130, 0, 0, 0,
	0, 0, 129, 0, 131, 0, 124, 0, 127, 126,
	128, 0, 123, 114, 130, 0, 0, 0, 0, 125,
	129, 113, 0, 0, 112, 0, 127, 0, 128, 122,
	123, 114, 0, 0, 0, 0, 0, 125, 0, 113,
	0, 103, 112, 0, 367, 465, 0, 122, 0, 109,
	110, 0, 0, 107, 108, 0, 0, 0, 0, 103,
	26, 0, 367, 362, 0, 0, 0, 109, 110, 0,
	0, 107, 108, 38, 119, 120, 27, 0, 0, 0,
	105, 106, 0, 0, 0, 0, 0, 28, 0, 0,
	0, 24, 23, 22, 0, 131, 155, 124, 0, 29,
	126, 0, 0, 30, 0, 130, 31, 0, 153, 0,
	0, 129, 21, 0, 0, 0, 0, 127, 0, 128,
	162, 123, 114, 0, 0, 0, 0, 0, 125, 0,
	113, 0, 0, 112, 0, 0, 0, 0, 122, 0,
	0, 0, 0, 0, 38, 119, 120, 0, 26, 0,
	103, 105, 106, 367, 0, 0, 0, 0, 109, 110,
	0, 0, 107, 108, 27, 0, 131, 0, 124, 0,
	9, 126, 0, 0, 0, 28, 130, 0, 6, 24,
	23, 22, 129, 0, 25, 0, 0, 29, 127, 0,
	128, 30, 123, 114, 31, 0, 11, 0, 0, 125,
	21, 113, 0, 0, 112, 0, 0, 0, 0, 122,
	0, 0, 661, 0, 0, 38, 119, 120, 0, 26,
	0, 103, 105, 106, 0, 0, 0, 0, 0, 109,
	110, 0, 0, 107, 108, 27, 0, 131, 0, 124,
	0, 9, 126, 0, 0, 0, 28, 130, 0, 0,
	24, 23, 22, 129, 0, 25, 0, 0, 29, 127,
	0, 128, 30, 123, 114, 31, 0, 11, 0, 0,
	125, 21, 113, 0, 0, 112, 0, 0, 0, 0,
	122, 0, 0, 655, 0, 0, 38, 119, 120, 0,
	26, 0, 103, 105, 106, 0, 0, 0, 0, 0,
	109, 110, 0, 0, 107, 108, 27, 0, 131, 0,
	124, 0, 0, 126, 0, 0, 0, 28, 130, 0,
	0, 24, 23, 22, 129, 0, 25, 0, 0, 29,
	127, 0, 128, 30, 123, 114, 31, 0, 11, 0,
	0, 125, 21, 113, 0, 0, 112, 0, 0, 0,
	0, 122, 0, 0, 602, 0, 38, 38, 119, 120,
	0, 0, 0, 103, 105, 106, 0, 0, 0, 0,
	0, 109, 110, 0, 0, 107, 108, 0, 131, 131,
	124, 124, 0, 126, 126, 0, 0, 0, 130, 130,
	0, 0, 0, 0, 129, 129, 0, 0, 0, 0,
	127, 127, 128, 128, 0, 123, 114, 0, 0, 0,
	0, 125, 125, 0, 113, 0, 0, 112, 0, 0,
	0, 438, 122, 0, 0, 422, 0, 398, 723, 119,
	120, 0, 0, 0, 103, 105, 106, 0, 0, 0,
	0, 0, 109, 110, 0, 0, 107, 108, 0, 131,
	131, 124, 124, 0, 126, 126, 0, 38, 0, 130,
	130, 0, 0, 0, 0, 129, 129, 0, 0, 0,
	0, 127, 127, 128, 128, 0, 123, 114, 0, 131,
	0, 124, 125, 125, 126, 113, 0, 0, 112, 130,
	0, 0, 397, 122, 0, 129, 0, 38, 119, 120,
	0, 127, 0, 128, 0, 103, 0, 0, 0, 0,
	0, 0, 125, 109, 110, 0, 0, 107, 108, 131,
	0, 124, 0, 0, 126, 0, 0, 0, 0, 130,
	0, 38, 0, 0, 0, 129, 0, 0, 0, 0,
	0, 127, 0, 128, 0, 123, 114, 0, 0, 0,
	0, 26, 125, 131, 113, 124, 0, 112, 126, 41,
	0, 0, 122, 130, 0, 42, 0, 27, 0, 129,
	0, 0, 0, 0, 449, 127, 43, 128, 28, 0,
	0, 0, 24, 23, 22, 260, 125, 25, 448, 0,
	29, 0, 0, 0, 30, 0, 308, 31, 0, 0,
	0, 0, 0, 44, 69, 26, 0, 131, 0, 124,
	0, 0, 126, 41, 0, 0, 0, 130, 0, 42,
	0, 27, 0, 129, 0, 0, 0, 0, 0, 127,
	43, 128, 28, 0, 0, 0, 24, 23, 22, 38,
	125, 25, 0, 0, 29, 0, 0, 0, 30, 0,
	259, 31, 0, 0, 0, 0, 0, 44, 69, 26,
	0, 131, 0, 124, 0, 0, 126, 41, 0, 0,
	0, 130, 0, 42, 0, 27, 0, 129, 0, 0,
	0, 26, 0, 127, 43, 128, 28, 0, 0, 0,
	24, 23, 22, 0, 125, 25, 0, 27, 29, 0,
	0, 0, 30, 0, 0, 31, 0, 26, 28, 0,
	0, 44, 24, 23, 22, 0, 0, 25, 0, 0,
	29, 0, 0, 27, 30, 0, 0, 31, 0, 180,
	0, 26, 0, 21, 28, 0, 0, 0, 24, 23,
	22, 0, 304, 25, 0, 0, 29, 27, 0, 0,
	30, 0, 0, 31, 0, 180, 0, 26, 28, 21,
	0, 0, 24, 23, 22, 0, 0, 25, 178, 0,
	29, 0, 0, 27, 30, 38, 0, 31, 0, 0,
	0, 0, 0, 21, 28, 0, 0, 0, 24, 23,
	22, 0, 440, 25, 0, 0, 29, 131, 0, 124,
	30, 0, 126, 31, 0, 0, 0, 130, 0, 21,
	0, 486, 0, 129, 0, 0, 0, 0, 310, 127,
	0, 128, 342, 343, 344, 345, 346, 347, 348, 349,
	125, 0, 0, 0, 26, 0, 0, 0, 0, 0,
	0, 0, 41, 0, 0, 0, 0, 21, 42, 0,
	27, 0, 0, 482, 0, 0, 0, 0, 0, 43,
	0, 28, 0, 0, 0, 24, 23, 22, 0, 0,
	25, 0, 0, 29, 0, 0, 0, 30, 0, 0,
	31, 0, 0, 0, 350, 351, 44, 0, 0, 0,
	341,
}
var JulyPact = []int{

	1864, -1000, -1000, 1935, 1935, 2006, 687, -1000, -1000, 647,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, 2550, -1000,
	-1000, 687, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, 1935, 2006, 2006, -1000, -1000, 498, -1000, 687,
	493, 769, 768, 766, 665, -1000, -1000, 326, 2006, 764,
	568, -1000, 469, 468, 568, 251, 239, 131, 762, 1517,
	-1000, -1000, 461, 568, 570, 203, 234, 137, -1000, 456,
	687, 2193, 907, 214, -1000, 86, 216, 186, -1000, 2193,
	2423, 199, 314, -1000, 446, -1000, -1000, -1000, -1000, -1000,
	281, 410, 1262, 677, 1, -2, 335, 710, 381, -6,
	14, -1000, 1444, 1444, 496, -1000, -1000, -1000, -1000, -1000,
	-1000, -8, 321, 321, 321, -1000, -15, 192, 137, -1000,
	-1000, 512, 490, 2193, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, 570, 568, 234, 137, -1000, 137, -1000, -1000,
	355, -1000, 440, 606, -1000, 419, 421, -1000, -1000, 382,
	731, -1000, -1000, -1000, -1000, 75, -1000, -1000, 2321, -1000,
	-1000, -1000, 1188, -1000, 109, 102, 129, -1000, -1000, 1776,
	453, 187, -1000, 186, -1000, -1000, 421, 2397, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, 2267, -1000, 2473, -1000,
	761, 1591, 1444, 1444, -1000, 68, 121, -1000, -1000, 1444,
	-1000, 1444, -1000, 1444, -1000, 1444, -1000, 1444, -1000, -1000,
	1444, 2193, 276, 254, 1444, -1000, -1000, 1444, -1000, -1000,
	-1000, -1000, 312, 74, 302, 2547, 485, 760, -1000, -1000,
	679, 1444, -1000, 1280, -1000, -1000, -1000, 1444, 1718, -1000,
	649, 642, 54, 568, 137, -1000, -1000, -1000, -1000, 759,
	687, 661, 656, 791, -1000, 2193, -1000, -1000, -1000, 754,
	285, 753, 2163, 661, -1000, 1097, -1000, -1000, -1000, -1000,
	1532, 702, -1000, -1000, 28, 567, 329, 1444, 327, 323,
	855, 322, 577, 557, 2093, 1444, 320, 193, -1000, -1000,
	464, 59, 106, 104, -1000, 65, -1000, -1000, 1776, -1000,
	187, 137, -1000, -1000, -1000, -1000, 752, 2092, 750, 2447,
	-1000, -1000, 2375, -1000, -1000, -1000, 281, -1000, 25, 677,
	1426, -1000, -1000, 1, -2, 335, 710, 381, -6, -1000,
	-1000, -1000, -1000, 353, 14, -1000, 2233, 348, 1444, 345,
	1444, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	363, 343, 749, 321, -1000, -1000, -1000, -20, 303, -1000,
	-1000, -21, -1000, 67, -1000, -1000, -1000, 1700, -1000, -1000,
	-1000, 321, 51, 656, -1000, 1444, -1000, -1000, 332, -1000,
	656, -1000, 369, -1000, -1000, 607, -1000, 285, -1000, 145,
	2511, -1000, 447, 220, -1000, -1000, 748, 746, 285, 656,
	-1000, -1000, -1000, -1000, 702, 430, -1000, 297, 855, -1000,
	1444, 37, 1444, 1444, 572, 320, 1353, 566, -1000, 564,
	-1000, 560, -1000, 550, 1444, 622, 75, 476, 63, -1000,
	-1000, -1000, -1000, 137, -1000, -1000, 229, 742, 738, 285,
	-1000, -1000, 728, 1444, -1000, -1000, -1000, 496, 1444, 1444,
	1444, -1000, 1444, -1000, 277, 241, -1000, -1000, -1000, -1000,
	1444, -1000, -1000, 1809, 41, -1000, -1000, -1000, 656, -1000,
	-26, 687, -1000, 791, 2193, 2193, -1000, 138, 75, -1000,
	687, 280, -1000, -1000, 1532, -1000, -1000, -1000, 502, -1000,
	702, -1000, -1000, 290, 1809, 161, 285, 285, -1000, 403,
	702, -1000, -1000, 311, 1444, -1000, 310, 309, 317, 308,
	-1000, -1000, -1000, -1000, 1532, 725, 395, 2022, 543, -1000,
	243, -1000, -1000, -1000, -1000, 307, 622, -1000, -1000, 75,
	298, 622, 279, -1000, 450, 725, -1000, -1000, -1000, 542,
	-1000, 405, 488, 284, 1809, 285, 285, -1000, 507, 163,
	-1000, 485, -32, 306, -1000, -1000, -1000, -1000, 263, -1000,
	-1000, 1609, -1000, -1000, -1000, -1000, -1000, -1000, 44, -1000,
	-1000, -1000, -1000, 404, 382, -1000, 1368, -1000, 482, 661,
	-1000, 1809, -1000, 73, 44, -1000, -1000, -1000, -1000, -1000,
	855, 538, 136, 855, 1444, 855, 725, 22, 661, 1951,
	1444, 537, 1444, 1880, 1809, 702, 75, -1000, -1000, -1000,
	476, 622, -1000, 232, -1000, 725, 250, -1000, 685, 487,
	534, -1000, 1809, -1000, -1000, -1000, 533, -1000, 526, 521,
	305, -1000, -16, -1000, -1000, -1000, -1000, 687, -1000, 475,
	656, -1000, 44, -1000, -1000, 610, -1000, 88, -1000, 304,
	-1000, 21, 1444, 656, 520, 1444, -1000, 1444, 379, -1000,
	516, 1444, 400, 371, -1000, 450, 90, 382, -1000, -1000,
	-1000, 238, 1444, 388, -1000, 282, 508, -1000, -1000, -1000,
	-1000, -1000, -1000, 631, 382, 715, -1000, 855, 66, -1000,
	-1000, 1005, -1000, 2164, 17, 451, 1444, -1000, 1444, 379,
	379, 1444, 1444, 379, 702, 89, 299, 687, 1444, -1000,
	685, 228, 1809, -1000, 621, 1591, 661, -1000, -1000, -1000,
	1188, -1000, 12, 6, -1000, -1000, -1000, 379, -1000, 379,
	371, 296, 75, 382, -1000, -1000, 1809, -1000, 1591, -1000,
	656, -1000, -1000, 75, -1000, -1000, -1000, -1000,
}
var JulyPgo = []int{

	0, 911, 910, 909, 775, 736, 72, 185, 904, 672,
	800, 16, 48, 46, 902, 901, 900, 896, 644, 10,
	463, 420, 67, 39, 60, 693, 534, 66, 895, 91,
	539, 259, 52, 43, 894, 29, 892, 41, 889, 44,
	9, 887, 885, 884, 6, 59, 8, 879, 878, 71,
	37, 876, 5, 875, 874, 30, 873, 872, 871, 34,
	26, 42, 13, 36, 869, 868, 61, 864, 863, 862,
	858, 18, 31, 857, 856, 1, 2, 855, 854, 22,
	53, 27, 21, 11, 853, 0, 848, 4, 7, 846,
	25, 845, 844, 17, 19, 843, 23, 12, 842, 14,
	15, 840, 3, 838, 837, 832, 830, 24, 826, 825,
	824, 821, 820, 55, 818, 54, 814, 62, 813, 58,
	811, 57, 809, 50, 805, 56, 804, 45, 797, 35,
	792, 790, 32, 20, 38, 789, 785, 784, 783, 51,
	781, 780, 33, 778, 47, 49, 777, 40, 776,
}
var JulyR1 = []int{

	0, 1, 2, 2, 2, 2, 2, 2, 2, 6,
	6, 7, 7, 8, 8, 3, 4, 4, 9, 9,
	9, 9, 5, 5, 10, 10, 11, 11, 12, 12,
	13, 13, 18, 20, 22, 14, 14, 14, 14, 14,
	14, 14, 14, 15, 15, 16, 16, 16, 16, 17,
	29, 29, 30, 30, 30, 19, 19, 19, 19, 33,
	33, 31, 31, 31, 31, 31, 31, 31, 31, 32,
	34, 34, 35, 35, 35, 35, 24, 36, 36, 37,
	37, 38, 38, 39, 39, 39, 39, 39, 39, 39,
	39, 39, 39, 23, 23, 23, 23, 23, 41, 41,
	40, 40, 40, 42, 42, 43, 43, 45, 44, 44,
	44, 47, 47, 47, 47, 48, 48, 25, 25, 50,
	50, 50, 50, 51, 51, 51, 51, 51, 51, 53,
	57, 57, 57, 58, 58, 61, 61, 62, 59, 59,
	59, 59, 54, 54, 55, 55, 56, 64, 64, 64,
	27, 27, 65, 65, 66, 66, 67, 67, 67, 67,
	68, 70, 70, 71, 71, 74, 74, 75, 75, 73,
	73, 72, 72, 72, 72, 77, 77, 69, 69, 69,
	63, 63, 78, 78, 79, 79, 81, 81, 81, 81,
	80, 80, 80, 80, 82, 82, 83, 83, 60, 60,
	60, 60, 76, 76, 86, 86, 84, 84, 84, 52,
	87, 87, 87, 88, 88, 88, 89, 89, 90, 90,
	90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
	90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
	90, 90, 90, 90, 90, 90, 93, 93, 96, 96,
	97, 97, 94, 95, 95, 98, 98, 99, 99, 91,
	91, 100, 101, 101, 102, 102, 102, 21, 21, 92,
	92, 92, 92, 103, 103, 105, 105, 105, 105, 104,
	104, 104, 104, 106, 106, 106, 106, 109, 109, 109,
	109, 110, 110, 107, 107, 108, 108, 85, 85, 111,
	111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
	111, 46, 46, 112, 112, 114, 113, 113, 116, 115,
	115, 118, 117, 117, 120, 119, 119, 122, 121, 121,
	124, 124, 123, 123, 123, 126, 126, 126, 126, 126,
	126, 126, 125, 125, 128, 128, 127, 127, 130, 130,
	130, 131, 131, 131, 131, 131, 131, 129, 129, 129,
	129, 129, 129, 129, 133, 133, 132, 132, 132, 132,
	132, 132, 132, 132, 134, 134, 134, 134, 134, 135,
	135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
	135, 135, 135, 135, 135, 139, 139, 140, 140, 137,
	137, 137, 138, 138, 136, 136, 136, 141, 141, 142,
	26, 26, 26, 26, 26, 26, 26, 26, 143, 143,
	145, 145, 145, 145, 145, 145, 145, 145, 49, 49,
	144, 144, 28, 28, 146, 146, 147, 147, 147, 147,
	148, 148, 148, 148,
}
var JulyR2 = []int{

	0, 1, 3, 2, 2, 1, 2, 1, 1, 1,
	2, 1, 3, 1, 3, 3, 1, 2, 6, 4,
	5, 3, 1, 2, 1, 1, 1, 1, 1, 1,
	1, 1, 2, 2, 2, 7, 6, 6, 5, 6,
	5, 5, 4, 5, 4, 6, 5, 5, 4, 5,
	1, 2, 1, 2, 1, 3, 2, 2, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 3,
	1, 3, 1, 3, 3, 1, 3, 1, 3, 3,
	1, 1, 3, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 0, 1, 1, 2, 2, 1, 2,
	5, 4, 2, 1, 1, 1, 3, 3, 1, 1,
	1, 4, 3, 3, 2, 1, 3, 3, 2, 1,
	1, 2, 1, 1, 4, 3, 1, 1, 1, 3,
	2, 2, 2, 1, 3, 1, 1, 2, 4, 3,
	3, 2, 3, 2, 3, 2, 3, 3, 3, 2,
	3, 2, 1, 2, 1, 1, 1, 1, 1, 1,
	4, 2, 1, 1, 3, 1, 3, 4, 3, 3,
	2, 4, 3, 3, 2, 3, 2, 5, 5, 4,
	3, 2, 1, 3, 2, 1, 6, 3, 5, 2,
	1, 1, 2, 2, 2, 1, 1, 3, 4, 2,
	3, 1, 1, 1, 1, 3, 4, 3, 2, 3,
	0, 1, 2, 1, 1, 1, 4, 3, 1, 1,
	3, 2, 7, 5, 5, 3, 7, 6, 5, 7,
	5, 3, 2, 3, 2, 3, 2, 3, 5, 3,
	4, 3, 5, 4, 4, 3, 1, 2, 7, 6,
	1, 3, 2, 4, 3, 1, 3, 5, 4, 1,
	2, 2, 1, 2, 3, 3, 2, 1, 3, 1,
	1, 1, 1, 5, 4, 4, 3, 3, 2, 5,
	4, 4, 3, 5, 4, 4, 3, 5, 3, 3,
	1, 3, 2, 1, 3, 1, 3, 1, 3, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 3, 3,
	4, 1, 5, 1, 3, 1, 1, 3, 1, 1,
	3, 1, 1, 3, 1, 1, 3, 1, 1, 3,
	1, 1, 1, 3, 3, 1, 1, 2, 2, 2,
	2, 3, 1, 3, 1, 1, 1, 3, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 2, 4, 5,
	4, 5, 2, 1, 1, 1, 1, 1, 1, 1,
	1, 3, 1, 3, 1, 3, 4, 1, 2, 1,
	1, 4, 6, 4, 3, 4, 3, 3, 3, 3,
	4, 2, 2, 2, 2, 3, 2, 1, 3, 1,
	3, 2, 3, 4, 4, 3, 3, 1, 2, 3,
	5, 4, 4, 3, 4, 3, 3, 2, 1, 3,
	4, 3, 3, 2, 3, 2, 2, 1, 1, 2,
	2, 1, 3, 2, 1, 2, 5, 5, 1, 1,
	5, 3, 4, 2,
}
var JulyChk = []int{

	-1000, -1, -2, -3, -4, -5, 54, -9, -10, 46,
	-11, 72, -12, -13, -14, -15, -16, -17, -23, -40,
	-39, 76, 57, 56, 55, 60, 24, 40, 51, 63,
	67, 70, -4, -5, -5, -9, -10, -7, 4, 60,
	-7, 32, 38, 49, 76, -39, -40, -7, -5, 73,
	-6, 72, -7, 73, -6, 4, 4, 4, 49, 81,
	4, 72, 73, -6, 75, -24, -18, -22, -25, 77,
	39, 45, 84, -22, -26, 84, -24, -20, -27, 39,
	84, 4, -42, 82, -43, -44, -45, -40, -46, -47,
	4, -112, 84, -113, -115, -117, -119, -121, -123, -125,
	-127, -129, -131, 81, -132, 11, 12, 93, 94, 89,
	90, -7, 64, 61, 53, -134, -135, -136, -138, 5,
	6, -31, 69, 52, 28, 59, 31, 48, 50, 42,
	36, 26, 75, -6, -18, -22, -25, -22, -25, -25,
	-36, -37, -24, 4, -19, -7, -21, -33, -31, -7,
	-49, 85, -50, 72, -51, 60, -52, -53, -23, -56,
	-12, -13, 84, -26, -143, 74, -144, 85, -145, 72,
	-41, 4, -40, -20, -27, -27, -21, -65, 85, -66,
	72, -67, -68, -69, -12, -13, -23, -28, 84, 82,
	74, 83, 79, -114, 9, -48, 74, 85, -44, -116,
	10, -118, 87, -120, 88, -122, 80, -124, 7, 8,
	-126, 47, 77, 78, -128, 89, 90, -130, 75, 91,
	92, -129, -85, -7, -31, -46, -133, 73, 11, 12,
	73, 95, -139, 81, -139, -139, -139, 95, 84, -25,
	73, 73, -33, -6, -22, -25, -25, -25, 78, 74,
	39, -32, -29, 77, 23, 74, 85, -50, -52, 69,
	4, -30, -24, -31, -19, -87, -88, -89, -11, -90,
	-80, -30, -52, 72, 4, -85, 44, 25, 62, 71,
	35, 43, 27, 33, 58, 65, 63, 68, 40, -40,
	-31, -7, 74, -144, 85, -144, 85, 85, -49, -40,
	4, -139, -25, -27, 85, -66, -30, -24, 69, -146,
	85, -147, -23, -12, -13, -45, 4, -44, -85, -113,
	74, 85, 85, -115, -117, -119, -121, -123, -125, -30,
	83, 77, 83, 78, -127, -129, 82, -29, 82, -29,
	-111, 83, 15, 16, 17, 18, 19, 20, 21, 22,
	77, 78, 73, 4, -134, 64, 32, -85, -140, 82,
	-85, -85, 85, -137, -76, -84, -85, 84, 32, 32,
	-139, -32, -141, -29, -142, 95, -25, -37, -38, -19,
	-29, 23, -34, -35, -30, 79, -33, 4, -55, -63,
	81, -57, -58, 4, -60, -64, -30, 69, 4, -29,
	85, -88, 40, -40, -30, -83, -60, 4, 86, 72,
	81, -85, 81, 81, -90, 63, 81, 4, 72, 4,
	72, -85, 72, -85, 81, -52, -95, 81, -144, 85,
	-145, 85, 85, -139, -25, -25, 4, -30, 69, 4,
	85, -147, -30, 86, 85, -44, 78, -132, 95, 81,
	82, -129, 82, -85, 77, 78, 4, -139, 96, 82,
	74, 96, 85, 74, -86, 85, -76, -139, -29, -142,
	-85, 80, 78, 74, 39, 61, -54, -63, -62, -52,
	66, -78, 82, -79, -80, -81, 40, -40, -30, 72,
	74, 72, -59, -29, 83, -63, 4, 4, -55, -83,
	74, 72, -90, -85, 86, 72, -85, -85, 71, -92,
	-103, -104, -105, -106, -80, -30, -108, 72, -109, -85,
	-110, 72, 72, 72, 72, -85, -93, -94, -96, 41,
	30, -52, -98, -99, -80, -19, 85, -25, -70, -71,
	-72, -73, -63, -29, 83, 4, 4, -77, -63, 4,
	-46, -133, -85, -85, -129, -129, 83, 83, 78, -85,
	-76, 74, 85, 96, -19, -35, -30, -30, -62, -61,
	-52, 72, -52, -8, -7, 82, 74, -81, 73, 4,
	-60, 83, -76, -29, -62, -61, -59, -59, 72, -60,
	82, -85, 82, 82, 81, 82, -30, -82, 4, 72,
	74, -85, 72, 72, 83, 74, 82, -94, -96, -52,
	81, -93, -94, 72, 82, -19, -82, 72, 74, -29,
	-62, 72, 83, -76, -72, -72, -62, 72, -148, -71,
	81, 96, 82, 83, -76, 85, -61, 74, -79, 73,
	-29, -76, -62, -61, -61, -90, 72, 84, -90, -85,
	-90, -82, 86, -29, -85, 72, -85, 72, -107, -85,
	-85, 72, -76, -83, -52, -80, -97, -7, -94, 82,
	-99, -82, 83, -74, -75, 4, -62, 72, 72, -76,
	72, 72, 72, 82, -7, 73, -61, 37, -91, 85,
	-100, -101, -102, 29, 34, 82, 86, -85, 72, -107,
	-107, 74, 72, -107, 74, -97, 4, 87, 83, -85,
	74, -29, 83, 72, 23, 34, 4, -90, 85, -100,
	-87, -102, -85, 4, 86, 72, -85, -107, -85, -107,
	-83, 4, 82, -7, -85, -75, 83, -76, 34, -44,
	-29, 86, 86, 82, -52, -76, -44, -52,
}
var JulyDef = []int{

	93, -2, 1, -2, -2, -2, 0, 16, 22, 0,
	24, 25, 26, 27, 28, 29, 30, 31, 0, 94,
	95, 0, 83, 84, 85, 86, 87, 88, 89, 90,
	91, 92, -2, -2, -2, 17, 23, 0, 11, 0,
	0, 0, 0, 0, 0, 96, 97, 102, -2, 0,
	15, 9, 0, 0, 21, 0, 0, 0, 0, 0,
	12, 10, 0, 19, 0, 0, 0, 0, 42, 0,
	0, 0, 93, 0, 44, 0, 0, 0, 48, 0,
	93, 0, 0, 101, 103, 104, 105, 108, 109, 110,
	11, 311, 0, 313, 316, 319, 322, 325, 328, 332,
	342, 346, 0, 0, 363, 351, 352, 353, 354, 355,
	356, 366, 367, 368, 369, 370, 372, 374, 377, 379,
	380, 0, 0, 0, 61, 62, 63, 64, 65, 66,
	67, 68, 0, 20, 0, 0, 38, 0, 40, 41,
	0, 77, 0, 80, 32, 58, 34, 267, 59, 60,
	93, 118, 428, 119, 120, 86, 122, 123, 0, 126,
	127, 128, -2, 43, 0, 0, 0, 417, 418, -2,
	0, 427, 98, 0, 46, 47, 33, 93, 151, 152,
	154, 155, 156, 157, 158, 159, 0, 49, 93, 100,
	0, 0, 0, 0, 315, 0, 0, 114, 115, 0,
	318, 0, 321, 0, 324, 0, 327, 0, 330, 331,
	0, 0, 335, 336, 0, 344, 345, 0, 348, 349,
	350, 357, 0, 366, 0, 297, 362, 0, 364, 365,
	0, 0, 394, 0, 391, 392, 393, 0, 0, 378,
	0, 0, 0, 18, 0, 36, 37, 39, 76, 0,
	0, 56, 57, 0, 50, 0, 117, 429, 121, 0,
	11, 0, 0, 52, 54, 93, 211, 213, 214, 215,
	0, 0, 218, 219, 11, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 90, 0, -2, -2,
	52, -2, 0, 0, 413, 0, 415, 416, -2, 99,
	423, 425, 426, 45, 150, 153, 0, 0, 0, 93,
	433, 434, 0, 438, 439, 106, 0, 107, 0, 314,
	0, 112, 113, 317, 320, 323, 326, 329, 333, 334,
	337, 339, 338, 340, 343, 347, 373, 0, 0, 0,
	0, 299, 300, 301, 302, 303, 304, 305, 306, 307,
	0, 0, 0, 384, 371, 386, 387, 0, 0, 396,
	397, 0, 375, 0, 399, 202, 203, 0, 388, 389,
	402, 0, 405, 406, 407, 0, 35, 78, 79, 81,
	55, 51, 0, 70, 72, 75, 268, 0, 125, 0,
	0, 129, 0, 201, 133, 146, 0, 0, 11, 53,
	209, 212, 192, 193, 0, 0, 196, 201, 0, 221,
	0, 0, 0, 0, 0, 0, 0, 0, 232, 0,
	234, 0, 236, 0, 0, 0, 0, 0, 0, 411,
	419, 412, 414, 421, 422, 424, 0, 0, 0, 0,
	432, 435, 0, 0, 111, 116, 341, 358, 0, 0,
	0, 360, 0, 298, 0, 0, 385, 390, 381, 395,
	0, 383, 376, 401, 0, 208, 204, 403, 404, 408,
	0, 0, 69, 0, 0, 0, 124, 0, 0, 145,
	0, 0, 181, 182, 0, 185, 190, 191, 0, 130,
	0, 131, 132, 199, 0, 0, 0, 0, 149, 0,
	0, 217, 220, 0, 0, 225, 0, 0, 0, 0,
	269, 270, 271, 272, 0, 0, 0, 0, 0, 295,
	290, 231, 233, 235, 237, 0, 239, 241, 246, 0,
	0, 245, 0, 255, 0, 0, 410, 420, 160, 0,
	162, 163, 0, 0, 0, 0, 0, 179, 0, 0,
	312, 0, 0, 0, 359, 361, 308, 309, 0, 398,
	400, 0, 207, 409, 82, 71, 73, 74, 0, 143,
	135, 136, 144, 137, 13, 180, 0, 184, 0, 189,
	134, 0, 200, 0, 0, 141, 147, 148, 216, 197,
	0, 0, 0, 0, 0, 0, 0, 292, 195, 0,
	0, 0, 278, 0, 0, 0, 0, 240, 247, 252,
	0, 243, 244, 0, 254, 0, 0, 161, 0, 0,
	0, 174, 0, 170, 177, 178, 0, 176, 0, 0,
	0, 382, 373, 310, 205, 206, 142, 0, 183, 0,
	187, 198, 0, 139, 140, 223, 224, 0, 228, 0,
	230, 291, 0, 194, 0, 282, 296, 276, 277, 293,
	0, 286, 288, 289, 238, 0, 0, 250, 242, 253,
	256, 0, 0, 164, 165, 0, 0, 172, 173, 169,
	175, 436, 437, 443, 14, 0, 138, 0, 0, 227,
	259, -2, 262, 0, 0, 0, 0, 274, 280, 281,
	275, 0, 284, 285, 0, 0, 0, 0, 0, 258,
	0, 0, 0, 171, 441, 0, 188, 222, 226, 260,
	-2, 263, 0, 11, 266, 229, 273, 279, 294, 283,
	287, 0, 0, 251, 257, 166, 0, 168, 0, 442,
	186, 264, 265, 0, 249, 167, 440, 248,
}
var JulyTok1 = []int{

	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 93, 3, 3, 3, 92, 80, 3,
	81, 82, 75, 89, 74, 90, 73, 91, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 86, 72,
	77, 83, 78, 79, 76, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 95, 3, 96, 88, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 84, 87, 85, 94,
}
var JulyTok2 = []int{

	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
	62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
}
var JulyTok3 = []int{
	0,
}

//line yaccpar:1

/*	parser for yacc output	*/

var JulyDebug = 0

type JulyLexer interface {
	Lex(lval *JulySymType) int
	Error(s string)
}

const JulyFlag = -1000

func JulyTokname(c int) string {
	// 4 is TOKSTART above
	if c >= 4 && c-4 < len(JulyToknames) {
		if JulyToknames[c-4] != "" {
			return JulyToknames[c-4]
		}
	}
	return fmt.Sprintf("tok-%v", c)
}

func JulyStatname(s int) string {
	if s >= 0 && s < len(JulyStatenames) {
		if JulyStatenames[s] != "" {
			return JulyStatenames[s]
		}
	}
	return fmt.Sprintf("state-%v", s)
}

func Julylex1(lex JulyLexer, lval *JulySymType) int {
	c := 0
	char := lex.Lex(lval)
	if char <= 0 {
		c = JulyTok1[0]
		goto out
	}
	if char < len(JulyTok1) {
		c = JulyTok1[char]
		goto out
	}
	if char >= JulyPrivate {
		if char < JulyPrivate+len(JulyTok2) {
			c = JulyTok2[char-JulyPrivate]
			goto out
		}
	}
	for i := 0; i < len(JulyTok3); i += 2 {
		c = JulyTok3[i+0]
		if c == char {
			c = JulyTok3[i+1]
			goto out
		}
	}

out:
	if c == 0 {
		c = JulyTok2[1] /* unknown char */
	}
	if JulyDebug >= 3 {
		fmt.Printf("lex %s(%d)\n", JulyTokname(c), uint(char))
	}
	return c
}

func JulyParse(Julylex JulyLexer) int {
	var Julyn int
	var Julylval JulySymType
	var JulyVAL JulySymType
	JulyS := make([]JulySymType, JulyMaxDepth)

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	Julystate := 0
	Julychar := -1
	Julyp := -1
	goto Julystack

ret0:
	return 0

ret1:
	return 1

Julystack:
	/* put a state and value onto the stack */
	if JulyDebug >= 4 {
		fmt.Printf("char %v in %v\n", JulyTokname(Julychar), JulyStatname(Julystate))
	}

	Julyp++
	if Julyp >= len(JulyS) {
		nyys := make([]JulySymType, len(JulyS)*2)
		copy(nyys, JulyS)
		JulyS = nyys
	}
	JulyS[Julyp] = JulyVAL
	JulyS[Julyp].yys = Julystate

Julynewstate:
	Julyn = JulyPact[Julystate]
	if Julyn <= JulyFlag {
		goto Julydefault /* simple state */
	}
	if Julychar < 0 {
		Julychar = Julylex1(Julylex, &Julylval)
	}
	Julyn += Julychar
	if Julyn < 0 || Julyn >= JulyLast {
		goto Julydefault
	}
	Julyn = JulyAct[Julyn]
	if JulyChk[Julyn] == Julychar { /* valid shift */
		Julychar = -1
		JulyVAL = Julylval
		Julystate = Julyn
		if Errflag > 0 {
			Errflag--
		}
		goto Julystack
	}

Julydefault:
	/* default state action */
	Julyn = JulyDef[Julystate]
	if Julyn == -2 {
		if Julychar < 0 {
			Julychar = Julylex1(Julylex, &Julylval)
		}

		/* look through exception table */
		xi := 0
		for {
			if JulyExca[xi+0] == -1 && JulyExca[xi+1] == Julystate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			Julyn = JulyExca[xi+0]
			if Julyn < 0 || Julyn == Julychar {
				break
			}
		}
		Julyn = JulyExca[xi+1]
		if Julyn < 0 {
			goto ret0
		}
	}
	if Julyn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			Julylex.Error("syntax error")
			Nerrs++
			if JulyDebug >= 1 {
				fmt.Printf("%s", JulyStatname(Julystate))
				fmt.Printf(" saw %s\n", JulyTokname(Julychar))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for Julyp >= 0 {
				Julyn = JulyPact[JulyS[Julyp].yys] + JulyErrCode
				if Julyn >= 0 && Julyn < JulyLast {
					Julystate = JulyAct[Julyn] /* simulate a shift of "error" */
					if JulyChk[Julystate] == JulyErrCode {
						goto Julystack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if JulyDebug >= 2 {
					fmt.Printf("error recovery pops state %d\n", JulyS[Julyp].yys)
				}
				Julyp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if JulyDebug >= 2 {
				fmt.Printf("error recovery discards %s\n", JulyTokname(Julychar))
			}
			if Julychar == JulyEofCode {
				goto ret1
			}
			Julychar = -1
			goto Julynewstate /* try again in the same state */
		}
	}

	/* reduction by production Julyn */
	if JulyDebug >= 2 {
		fmt.Printf("reduce %v in:\n\t%v\n", Julyn, JulyStatname(Julystate))
	}

	Julynt := Julyn
	Julypt := Julyp
	_ = Julypt // guard against "declared and not used"

	Julyp -= JulyR2[Julyn]
	JulyVAL = JulyS[Julyp+1]

	/* consult goto table to find next state */
	Julyn = JulyR1[Julyn]
	Julyg := JulyPgo[Julyn]
	Julyj := Julyg + JulyS[Julyp].yys + 1

	if Julyj >= JulyLast {
		Julystate = JulyAct[Julyg]
	} else {
		Julystate = JulyAct[Julyj]
		if JulyChk[Julystate] != -Julyn {
			Julystate = JulyAct[Julyg]
		}
	}
	// dummy call; replaced with literal code
	switch Julynt {

	case 1:
		//line grammar/java11.y:173
		{
			var mylex *myLexer
			if l, ok := Julylex.(*myLexer); !ok {
				panic(fmt.Sprintf("bad lexer type %T (should be *myLexer)",
					Julylex))
			} else {
				mylex = l
			}

			if prog, ok := JulyS[Julypt-0].obj.(*JProgramFile); !ok {
				ReportCastError("JProgramFile", JulyS[Julypt-0].obj)
			} else {

				mylex.SetJavaProgram(prog)
			}
		}
	case 2:
		//line grammar/java11.y:193
		{
			JulyVAL.obj = NewJProgramFile(JulyS[Julypt-2].obj, JulyS[Julypt-1].objlist, JulyS[Julypt-0].objlist)
		}
	case 3:
		//line grammar/java11.y:195
		{
			JulyVAL.obj = NewJProgramFile(JulyS[Julypt-1].obj, JulyS[Julypt-0].objlist, nil)
		}
	case 4:
		//line grammar/java11.y:197
		{
			JulyVAL.obj = NewJProgramFile(JulyS[Julypt-1].obj, nil, JulyS[Julypt-0].objlist)
		}
	case 5:
		//line grammar/java11.y:199
		{
			JulyVAL.obj = NewJProgramFile(JulyS[Julypt-0].obj, nil, nil)
		}
	case 6:
		//line grammar/java11.y:201
		{
			JulyVAL.obj = NewJProgramFile(nil, JulyS[Julypt-1].objlist, JulyS[Julypt-0].objlist)
		}
	case 7:
		//line grammar/java11.y:203
		{
			JulyVAL.obj = NewJProgramFile(nil, JulyS[Julypt-0].objlist, nil)
		}
	case 8:
		//line grammar/java11.y:205
		{
			JulyVAL.obj = NewJProgramFile(nil, nil, JulyS[Julypt-0].objlist)
		}
	case 9:
		//line grammar/java11.y:210
		{
			JulyVAL.count = 1
		}
	case 10:
		//line grammar/java11.y:212
		{
			JulyVAL.count += 1
		}
	case 11:
		//line grammar/java11.y:217
		{
			JulyVAL.name = NewJTypeName(JulyS[Julypt-0].str, false)
		}
	case 12:
		//line grammar/java11.y:219
		{
			JulyS[Julypt-2].name.Add(JulyS[Julypt-0].str)
			JulyVAL.name = JulyS[Julypt-2].name
		}
	case 13:
		//line grammar/java11.y:227
		{
			JulyVAL.namelist = make([]*JTypeName, 1)
			JulyVAL.namelist[0] = JulyS[Julypt-0].name
		}
	case 14:
		//line grammar/java11.y:232
		{
			JulyVAL.namelist = append(JulyS[Julypt-2].namelist, JulyS[Julypt-0].name)
		}
	case 15:
		//line grammar/java11.y:237
		{
			JulyVAL.obj = NewJPackageStmt(JulyS[Julypt-1].name)
		}
	case 16:
		//line grammar/java11.y:242
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 17:
		//line grammar/java11.y:247
		{
			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
		}
	case 18:
		//line grammar/java11.y:252
		{
			JulyVAL.obj = NewJImportStmt(JulyS[Julypt-3].name, true, true)
		}
	case 19:
		//line grammar/java11.y:254
		{
			JulyVAL.obj = NewJImportStmt(JulyS[Julypt-1].name, false, true)
		}
	case 20:
		//line grammar/java11.y:256
		{
			JulyVAL.obj = NewJImportStmt(JulyS[Julypt-3].name, true, false)
		}
	case 21:
		//line grammar/java11.y:258
		{
			JulyVAL.obj = NewJImportStmt(JulyS[Julypt-1].name, false, false)
		}
	case 22:
		//line grammar/java11.y:263
		{
			JulyVAL.objlist = make([]JObject, 1)
			if JulyS[Julypt-0].obj != nil {
				JulyVAL.objlist[0] = JulyS[Julypt-0].obj
			}
		}
	case 23:
		//line grammar/java11.y:270
		{
			if JulyS[Julypt-0].obj == nil {
				JulyVAL.objlist = JulyS[Julypt-1].objlist
			} else {
				JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
			}
		}
	case 24:
		//line grammar/java11.y:281
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 25:
		//line grammar/java11.y:283
		{
			JulyVAL.obj = nil
		}
	case 26:
		//line grammar/java11.y:288
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 27:
		//line grammar/java11.y:290
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 28:
		//line grammar/java11.y:295
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 29:
		//line grammar/java11.y:297
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 30:
		//line grammar/java11.y:302
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 31:
		//line grammar/java11.y:304
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 32:
		//line grammar/java11.y:309
		{
			if jtyp, ok := JulyS[Julypt-0].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = jtyp
			}
		}
	case 33:
		//line grammar/java11.y:320
		{
			JulyVAL.namelist = JulyS[Julypt-0].namelist
		}
	case 34:
		//line grammar/java11.y:325
		{
			JulyVAL.namelist = JulyS[Julypt-0].namelist
		}
	case 35:
		//line grammar/java11.y:330
		{
			if jmod, ok := JulyS[Julypt-6].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-6].obj)
			} else if jtyp, ok := JulyS[Julypt-2].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-2].obj)
			} else {
				JulyVAL.obj = NewJClassDecl(jmod, JulyS[Julypt-4].str, JulyS[Julypt-3].objlist, jtyp,
					JulyS[Julypt-1].namelist, JulyS[Julypt-0].objlist)
			}
		}
	case 36:
		//line grammar/java11.y:341
		{
			if jmod, ok := JulyS[Julypt-5].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-5].obj)
			} else if jtyp, ok := JulyS[Julypt-1].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-1].obj)
			} else {
				JulyVAL.obj = NewJClassDecl(jmod, JulyS[Julypt-3].str, JulyS[Julypt-2].objlist, jtyp, nil,
					JulyS[Julypt-0].objlist)
			}
		}
	case 37:
		//line grammar/java11.y:352
		{
			if jmod, ok := JulyS[Julypt-5].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-5].obj)
			} else {
				JulyVAL.obj = NewJClassDecl(jmod, JulyS[Julypt-3].str, JulyS[Julypt-2].objlist, nil,
					JulyS[Julypt-1].namelist, JulyS[Julypt-0].objlist)
			}
		}
	case 38:
		//line grammar/java11.y:361
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else {
				JulyVAL.obj = NewJClassDecl(jmod, JulyS[Julypt-2].str, JulyS[Julypt-1].objlist, nil, nil,
					JulyS[Julypt-0].objlist)
			}
		}
	case 39:
		//line grammar/java11.y:370
		{
			if jmod, ok := JulyS[Julypt-5].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-5].obj)
			} else if jtyp, ok := JulyS[Julypt-2].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-2].obj)
			} else {
				JulyVAL.obj = NewJClassDecl(jmod, JulyS[Julypt-3].str, nil, jtyp, JulyS[Julypt-1].namelist,
					JulyS[Julypt-0].objlist)
			}
		}
	case 40:
		//line grammar/java11.y:381
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else if jtyp, ok := JulyS[Julypt-1].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-1].obj)
			} else {
				JulyVAL.obj = NewJClassDecl(jmod, JulyS[Julypt-2].str, nil, jtyp, nil,
					JulyS[Julypt-0].objlist)
			}
		}
	case 41:
		//line grammar/java11.y:392
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else {
				JulyVAL.obj = NewJClassDecl(jmod, JulyS[Julypt-2].str, nil, nil, JulyS[Julypt-1].namelist,
					JulyS[Julypt-0].objlist)
			}
		}
	case 42:
		//line grammar/java11.y:401
		{
			if jmod, ok := JulyS[Julypt-3].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-3].obj)
			} else {
				JulyVAL.obj = NewJClassDecl(jmod, JulyS[Julypt-1].str, nil, nil, nil, JulyS[Julypt-0].objlist)
			}
		}
	case 43:
		//line grammar/java11.y:412
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else if jbody, ok := JulyS[Julypt-0].obj.(*JEnumBody); !ok {
				ReportCastError("JEnumBody", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJEnumDecl(jmod, JulyS[Julypt-2].str, JulyS[Julypt-1].namelist, jbody)
			}
		}
	case 44:
		//line grammar/java11.y:422
		{
			if jmod, ok := JulyS[Julypt-3].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-3].obj)
			} else if jbody, ok := JulyS[Julypt-0].obj.(*JEnumBody); !ok {
				ReportCastError("JEnumBody", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJEnumDecl(jmod, JulyS[Julypt-1].str, nil, jbody)
			}
		}
	case 45:
		//line grammar/java11.y:435
		{
			if jmod, ok := JulyS[Julypt-5].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-5].obj)
			} else {
				JulyVAL.obj = NewJInterfaceDecl(jmod, NewJTypeName(JulyS[Julypt-3].str, false),
					JulyS[Julypt-2].objlist, JulyS[Julypt-1].namelist, JulyS[Julypt-0].objlist)
			}
		}
	case 46:
		//line grammar/java11.y:444
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else {
				JulyVAL.obj = NewJInterfaceDecl(jmod, NewJTypeName(JulyS[Julypt-2].str, false),
					JulyS[Julypt-1].objlist, nil, JulyS[Julypt-0].objlist)
			}
		}
	case 47:
		//line grammar/java11.y:453
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else {
				JulyVAL.obj = NewJInterfaceDecl(jmod, NewJTypeName(JulyS[Julypt-2].str, false),
					nil, JulyS[Julypt-1].namelist, JulyS[Julypt-0].objlist)
			}
		}
	case 48:
		//line grammar/java11.y:462
		{
			if jmod, ok := JulyS[Julypt-3].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-3].obj)
			} else {
				JulyVAL.obj = NewJInterfaceDecl(jmod, NewJTypeName(JulyS[Julypt-1].str, false),
					nil, nil, JulyS[Julypt-0].objlist)
			}
		}
	case 49:
		//line grammar/java11.y:474
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationTypeDeclaration#0")
		}
	case 50:
		//line grammar/java11.y:479
		{
			JulyVAL.count = 1
		}
	case 51:
		//line grammar/java11.y:481
		{
			JulyVAL.count = JulyS[Julypt-1].count + 1
		}
	case 52:
		//line grammar/java11.y:486
		{
			JulyVAL.obj = NewJReferenceType(NewJTypeName(JulyS[Julypt-0].str, true), nil, 0)
		}
	case 53:
		//line grammar/java11.y:488
		{
			JulyVAL.obj = NewJReferenceType(NewJTypeName(JulyS[Julypt-1].str, true), nil,
				JulyS[Julypt-0].count)
		}
	case 54:
		//line grammar/java11.y:493
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 55:
		//line grammar/java11.y:498
		{
			JulyVAL.obj = NewJReferenceType(JulyS[Julypt-2].name, JulyS[Julypt-1].objlist, JulyS[Julypt-0].count)
		}
	case 56:
		//line grammar/java11.y:500
		{
			JulyVAL.obj = NewJReferenceType(JulyS[Julypt-1].name, JulyS[Julypt-0].objlist, 0)
		}
	case 57:
		//line grammar/java11.y:502
		{
			JulyVAL.obj = NewJReferenceType(JulyS[Julypt-1].name, nil, JulyS[Julypt-0].count)
		}
	case 58:
		//line grammar/java11.y:504
		{
			JulyVAL.obj = NewJReferenceType(JulyS[Julypt-0].name, nil, 0)
		}
	case 59:
		//line grammar/java11.y:509
		{
			JulyVAL.name = NewJTypeName(JulyS[Julypt-0].str, true)
		}
	case 60:
		//line grammar/java11.y:511
		{
			JulyVAL.name = JulyS[Julypt-0].name
		}
	case 61:
		//line grammar/java11.y:516
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 62:
		//line grammar/java11.y:518
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 63:
		//line grammar/java11.y:520
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 64:
		//line grammar/java11.y:522
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 65:
		//line grammar/java11.y:524
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 66:
		//line grammar/java11.y:526
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 67:
		//line grammar/java11.y:528
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 68:
		//line grammar/java11.y:530
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 69:
		//line grammar/java11.y:535
		{
			JulyVAL.objlist = JulyS[Julypt-1].objlist
		}
	case 70:
		//line grammar/java11.y:540
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 71:
		//line grammar/java11.y:545
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 72:
		//line grammar/java11.y:550
		{
			if jtyp, ok := JulyS[Julypt-0].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJTypeArgument(jtyp, TS_NONE)
			}
		}
	case 73:
		//line grammar/java11.y:558
		{
			if jtyp, ok := JulyS[Julypt-0].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJTypeArgument(jtyp, TS_EXTENDS)
			}
		}
	case 74:
		//line grammar/java11.y:566
		{
			if jtyp, ok := JulyS[Julypt-0].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJTypeArgument(jtyp, TS_SUPER)
			}
		}
	case 75:
		//line grammar/java11.y:574
		{
			JulyVAL.obj = NewJTypeArgument(nil, TS_PLAIN)
		}
	case 76:
		//line grammar/java11.y:579
		{
			JulyVAL.objlist = JulyS[Julypt-1].objlist
		}
	case 77:
		//line grammar/java11.y:584
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 78:
		//line grammar/java11.y:589
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-1].obj)
		}
	case 79:
		//line grammar/java11.y:594
		{
			JulyVAL.obj = NewJTypeParameter(JulyS[Julypt-2].str, JulyS[Julypt-0].objlist)
		}
	case 80:
		//line grammar/java11.y:596
		{
			JulyVAL.obj = NewJTypeParameter(JulyS[Julypt-0].str, nil)
		}
	case 81:
		//line grammar/java11.y:601
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 82:
		//line grammar/java11.y:606
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-1].obj)
		}
	case 83:
		//line grammar/java11.y:611
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 84:
		//line grammar/java11.y:613
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 85:
		//line grammar/java11.y:615
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 86:
		//line grammar/java11.y:617
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 87:
		//line grammar/java11.y:619
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 88:
		//line grammar/java11.y:621
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 89:
		//line grammar/java11.y:623
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 90:
		//line grammar/java11.y:625
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 91:
		//line grammar/java11.y:627
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 92:
		//line grammar/java11.y:629
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 93:
		//line grammar/java11.y:634
		{
			JulyVAL.obj = NewJModifiers("", nil)
		}
	case 94:
		//line grammar/java11.y:638
		{
			if jann, ok := JulyS[Julypt-0].obj.(*JAnnotation); !ok {
				ReportCastError("JAnnotation", JulyS[Julypt-0].obj)
			} else {
				jmod := NewJModifiers("", jann)
				JulyVAL.obj = jmod
			}
		}
	case 95:
		//line grammar/java11.y:647
		{
			JulyVAL.obj = NewJModifiers(JulyS[Julypt-0].str, nil)
		}
	case 96:
		//line grammar/java11.y:649
		{
			if jmod, ok := JulyS[Julypt-1].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-1].obj)
			} else {
				jmod.AddModifier(JulyS[Julypt-0].str)
				JulyVAL.obj = jmod
			}
		}
	case 97:
		//line grammar/java11.y:658
		{
			if jmod, ok := JulyS[Julypt-1].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-1].obj)
			} else {
				if jann, ok := JulyS[Julypt-0].obj.(*JAnnotation); !ok {
					ReportCastError("JAnnotation", JulyS[Julypt-0].obj)
				} else {
					jmod.AddAnnotation(jann)
					JulyVAL.obj = jmod
				}
			}
		}
	case 98:
		//line grammar/java11.y:674
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 99:
		//line grammar/java11.y:679
		{
			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
		}
	case 100:
		//line grammar/java11.y:684
		{
			JulyVAL.obj = NewJAnnotation(JulyS[Julypt-3].name, JulyS[Julypt-1].objlist, true)
		}
	case 101:
		//line grammar/java11.y:686
		{
			JulyVAL.obj = NewJAnnotation(JulyS[Julypt-2].name, nil, true)
		}
	case 102:
		//line grammar/java11.y:688
		{
			JulyVAL.obj = NewJAnnotation(JulyS[Julypt-0].name, nil, false)
		}
	case 103:
		//line grammar/java11.y:693
		{
			JulyVAL.objlist = JulyS[Julypt-0].objlist
		}
	case 104:
		//line grammar/java11.y:695
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 105:
		//line grammar/java11.y:703
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 106:
		//line grammar/java11.y:708
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-1].obj)
		}
	case 107:
		//line grammar/java11.y:713
		{
			JulyVAL.obj = NewJElementValuePair(JulyS[Julypt-2].str, JulyS[Julypt-0].obj)
		}
	case 108:
		//line grammar/java11.y:718
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 109:
		//line grammar/java11.y:720
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 110:
		//line grammar/java11.y:722
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 111:
		//line grammar/java11.y:727
		{
			JulyVAL.obj = NewJUnimplemented("ElementValueArrayInitializer#0")
		}
	case 112:
		//line grammar/java11.y:729
		{
			JulyVAL.obj = NewJUnimplemented("ElementValueArrayInitializer#1")
		}
	case 113:
		//line grammar/java11.y:731
		{
			JulyVAL.obj = NewJUnimplemented("ElementValueArrayInitializer#2")
		}
	case 114:
		//line grammar/java11.y:733
		{
			JulyVAL.obj = NewJUnimplemented("ElementValueArrayInitializer#3")
		}
	case 115:
		//line grammar/java11.y:738
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 116:
		//line grammar/java11.y:743
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 117:
		//line grammar/java11.y:748
		{
			JulyVAL.objlist = JulyS[Julypt-1].objlist
		}
	case 118:
		//line grammar/java11.y:750
		{
			JulyVAL.objlist = nil
		}
	case 119:
		//line grammar/java11.y:755
		{
			JulyVAL.obj = NewJEmpty()
		}
	case 120:
		//line grammar/java11.y:757
		{
			JulyVAL.obj = NewJClassBody(JulyS[Julypt-0].objlist)
		}
	case 121:
		//line grammar/java11.y:761
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				jblk.SetStatic()
				JulyVAL.obj = jblk
			}
		}
	case 122:
		//line grammar/java11.y:770
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = jblk
			}
		}
	case 123:
		//line grammar/java11.y:781
		{
			if JulyS[Julypt-0].objlist == nil || len(JulyS[Julypt-0].objlist) == 0 {
				panic("Got empty list from MethodOrFieldDecl")
			}

			JulyVAL.objlist = JulyS[Julypt-0].objlist
		}
	case 124:
		//line grammar/java11.y:789
		{
			if jmod, ok := JulyS[Julypt-3].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-3].obj)
			} else if jmth, ok := JulyS[Julypt-0].obj.(*JMethodDecl); !ok {
				ReportCastError("JMethodDecl", JulyS[Julypt-0].obj)
			} else {
				jmth.SetModifiers(jmod)
				jmth.SetName(JulyS[Julypt-1].str)

				JulyVAL.objlist = make([]JObject, 1)
				JulyVAL.objlist[0] = jmth
			}
		}
	case 125:
		//line grammar/java11.y:803
		{
			if jmod, ok := JulyS[Julypt-2].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-2].obj)
			} else if jmth, ok := JulyS[Julypt-0].obj.(*JMethodDecl); !ok {
				ReportCastError("JMethodDecl", JulyS[Julypt-0].obj)
			} else {
				jmth.SetModifiers(jmod)
				jmth.SetName(JulyS[Julypt-1].str)
				jmth.SetType(NewJReferenceType(NewJTypeName(JulyS[Julypt-0].str, false),
					nil, 0))

				JulyVAL.objlist = make([]JObject, 1)
				JulyVAL.objlist[0] = jmth
			}
		}
	case 126:
		//line grammar/java11.y:819
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 127:
		//line grammar/java11.y:824
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 128:
		//line grammar/java11.y:829
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 129:
		//line grammar/java11.y:837
		{
			if jmod, ok := JulyS[Julypt-2].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-2].obj)
			} else if jtyp, ok := JulyS[Julypt-1].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-1].obj)
			} else if JulyS[Julypt-0].objlist == nil || len(JulyS[Julypt-0].objlist) == 0 {
				panic("MethodOrFieldRest list is nil/empty")
			} else {
				for _, obj := range JulyS[Julypt-0].objlist {
					if jmth, ok := obj.(*JMethodDecl); ok {
						jmth.SetModifiers(jmod)
						jmth.SetType(jtyp)
					} else if jvar, ok := obj.(*JVariableDecl); ok {
						jvar.SetModifiers(jmod)
						jvar.SetType(jtyp)
					} else {
						ReportCastError("MethodOrFieldDecl", obj)
					}
				}
				JulyVAL.objlist = JulyS[Julypt-0].objlist
			}
		}
	case 130:
		//line grammar/java11.y:863
		{
			JulyVAL.objlist = JulyS[Julypt-1].objlist
		}
	case 131:
		//line grammar/java11.y:865
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = NewJVariableDecl(JulyS[Julypt-1].str, 0, nil)
		}
	case 132:
		//line grammar/java11.y:870
		{
			if jmth, ok := JulyS[Julypt-0].obj.(*JMethodDecl); !ok {
				ReportCastError("JMethodDecl", JulyS[Julypt-0].obj)
			} else {
				jmth.SetName(JulyS[Julypt-1].str)
				JulyVAL.objlist = make([]JObject, 1)
				JulyVAL.objlist[0] = jmth
			}
		}
	case 133:
		//line grammar/java11.y:883
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 134:
		//line grammar/java11.y:888
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 135:
		//line grammar/java11.y:893
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = jblk
			}
		}
	case 136:
		//line grammar/java11.y:901
		{
			JulyVAL.obj = NewJBlock(nil)
		}
	case 137:
		//line grammar/java11.y:906
		{
			JulyVAL.namelist = JulyS[Julypt-0].namelist
		}
	case 138:
		//line grammar/java11.y:911
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJMethodDecl(makeFormalParamList(JulyS[Julypt-3].objlist),
					JulyS[Julypt-2].count, JulyS[Julypt-1].namelist, jblk)
			}
		}
	case 139:
		//line grammar/java11.y:920
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJMethodDecl(makeFormalParamList(JulyS[Julypt-2].objlist),
					JulyS[Julypt-1].count, nil, jblk)
			}
		}
	case 140:
		//line grammar/java11.y:929
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJMethodDecl(makeFormalParamList(JulyS[Julypt-2].objlist),
					0, JulyS[Julypt-1].namelist, jblk)
			}
		}
	case 141:
		//line grammar/java11.y:938
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJMethodDecl(makeFormalParamList(JulyS[Julypt-1].objlist),
					0, nil, jblk)
			}
		}
	case 142:
		//line grammar/java11.y:950
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				jmth := NewJMethodDecl(makeFormalParamList(JulyS[Julypt-2].objlist), 0,
					JulyS[Julypt-1].namelist, jblk)
				jmth.SetType(NewJReferenceType(NewJTypeName("void", true),
					nil, 0))
				JulyVAL.obj = jmth
			}
		}
	case 143:
		//line grammar/java11.y:962
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				jmth := NewJMethodDecl(makeFormalParamList(JulyS[Julypt-1].objlist), 0,
					nil, jblk)
				jmth.SetType(NewJReferenceType(NewJTypeName("void", true),
					nil, 0))
				JulyVAL.obj = jmth
			}
		}
	case 144:
		//line grammar/java11.y:977
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJMethodDecl(makeFormalParamList(JulyS[Julypt-2].objlist), 0,
					JulyS[Julypt-1].namelist, jblk)
			}
		}
	case 145:
		//line grammar/java11.y:986
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJMethodDecl(makeFormalParamList(JulyS[Julypt-1].objlist), 0,
					nil, jblk)
			}
		}
	case 146:
		//line grammar/java11.y:998
		{
			if jmod, ok := JulyS[Julypt-2].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-2].obj)
			} else if jmth, ok := JulyS[Julypt-0].obj.(*JMethodDecl); !ok {
				ReportCastError("JMethodDecl", JulyS[Julypt-0].obj)
			} else {
				jmth.SetModifiers(jmod)
				jmth.SetTypeParameters(JulyS[Julypt-1].objlist)
				JulyVAL.obj = jmth
			}
		}
	case 147:
		//line grammar/java11.y:1013
		{
			if jmth, ok := JulyS[Julypt-0].obj.(*JMethodDecl); !ok {
				ReportCastError("JMethodDecl", JulyS[Julypt-0].obj)
			} else {
				if jtyp, ok := JulyS[Julypt-2].obj.(*JReferenceType); !ok {
					ReportCastError("JReferenceType", JulyS[Julypt-2].obj)
				} else {
					jmth.SetType(jtyp)
					jmth.SetName(JulyS[Julypt-1].str)
					JulyVAL.obj = jmth
				}
			}
		}
	case 148:
		//line grammar/java11.y:1027
		{
			if jmth, ok := JulyS[Julypt-0].obj.(*JMethodDecl); !ok {
				ReportCastError("JMethodDecl", JulyS[Julypt-0].obj)
			} else {
				jmth.SetType(NewJReferenceType(NewJTypeName(JulyS[Julypt-2].str, false),
					nil, 0))
				jmth.SetName(JulyS[Julypt-1].str)
				JulyVAL.obj = jmth
			}
		}
	case 149:
		//line grammar/java11.y:1038
		{
			if jmth, ok := JulyS[Julypt-0].obj.(*JMethodDecl); !ok {
				ReportCastError("JMethodDecl", JulyS[Julypt-0].obj)
			} else {
				jmth.SetName(JulyS[Julypt-1].str)
				jmth.SetType(NewJReferenceType(NewJTypeName(JulyS[Julypt-1].str, false),
					nil, 0))
				JulyVAL.obj = jmth
			}
		}
	case 150:
		//line grammar/java11.y:1052
		{
			JulyVAL.objlist = JulyS[Julypt-1].objlist
		}
	case 151:
		//line grammar/java11.y:1054
		{
			JulyVAL.objlist = make([]JObject, 0)
		}
	case 152:
		//line grammar/java11.y:1059
		{
			JulyVAL.objlist = JulyS[Julypt-0].objlist
		}
	case 153:
		//line grammar/java11.y:1063
		{
			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].objlist...)
		}
	case 154:
		//line grammar/java11.y:1068
		{
			JulyVAL.objlist = make([]JObject, 0)
		}
	case 155:
		//line grammar/java11.y:1072
		{
			JulyVAL.objlist = JulyS[Julypt-0].objlist
		}
	case 156:
		//line grammar/java11.y:1077
		{
			JulyVAL.objlist = JulyS[Julypt-0].objlist
		}
	case 157:
		//line grammar/java11.y:1079
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 158:
		//line grammar/java11.y:1084
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 159:
		//line grammar/java11.y:1089
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 160:
		//line grammar/java11.y:1097
		{
			if jmod, ok := JulyS[Julypt-3].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-3].obj)
			} else if jtyp, ok := JulyS[Julypt-2].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-2].obj)
			} else if JulyS[Julypt-0].objlist == nil || len(JulyS[Julypt-0].objlist) == 0 {
				panic("InterfaceMethodOrFieldRest list is nil/empty")
			} else {
				for _, obj := range JulyS[Julypt-0].objlist {
					if jimd, ok := obj.(*JInterfaceMethodDecl); ok {
						jimd.SetModifiers(jmod)
						jimd.SetType(jtyp)
						jimd.SetName(JulyS[Julypt-1].str)
					} else if jcd, ok := obj.(*JConstantDecl); ok {
						jcd.SetModifiers(jmod)
						jcd.SetType(jtyp)
						if !jcd.HasName() {
							jcd.SetName(JulyS[Julypt-1].str)
						}
					} else {
						ReportCastError("InterfaceMethodOrFieldDecl", obj)
					}
				}
				JulyVAL.objlist = JulyS[Julypt-0].objlist
			}
		}
	case 161:
		//line grammar/java11.y:1127
		{
			JulyVAL.objlist = JulyS[Julypt-1].objlist
		}
	case 162:
		//line grammar/java11.y:1131
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 163:
		//line grammar/java11.y:1139
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 164:
		//line grammar/java11.y:1144
		{
			JulyVAL.objlist = append(JulyS[Julypt-0].objlist, JulyS[Julypt-2].obj)
		}
	case 165:
		//line grammar/java11.y:1149
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 166:
		//line grammar/java11.y:1154
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 167:
		//line grammar/java11.y:1159
		{
			if init, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJConstantDecl(JulyS[Julypt-3].str, JulyS[Julypt-2].count, init)
			}
		}
	case 168:
		//line grammar/java11.y:1167
		{
			if init, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJConstantDecl(JulyS[Julypt-2].str, 0, init)
			}
		}
	case 169:
		//line grammar/java11.y:1178
		{
			if init, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJConstantDecl("", JulyS[Julypt-2].count, init)
			}
		}
	case 170:
		//line grammar/java11.y:1186
		{
			if init, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJConstantDecl("", 0, init)
			}
		}
	case 171:
		//line grammar/java11.y:1197
		{
			JulyVAL.obj = NewJInterfaceMethodDecl(makeFormalParamList(JulyS[Julypt-3].objlist),
				JulyS[Julypt-2].count, JulyS[Julypt-1].namelist)
		}
	case 172:
		//line grammar/java11.y:1202
		{
			JulyVAL.obj = NewJInterfaceMethodDecl(makeFormalParamList(JulyS[Julypt-2].objlist),
				JulyS[Julypt-1].count, nil)
		}
	case 173:
		//line grammar/java11.y:1207
		{
			JulyVAL.obj = NewJInterfaceMethodDecl(makeFormalParamList(JulyS[Julypt-2].objlist),
				0, JulyS[Julypt-0].namelist)
		}
	case 174:
		//line grammar/java11.y:1212
		{
			JulyVAL.obj = NewJInterfaceMethodDecl(makeFormalParamList(JulyS[Julypt-1].objlist),
				0, nil)
		}
	case 175:
		//line grammar/java11.y:1220
		{
			JulyVAL.obj = NewJInterfaceMethodDecl(makeFormalParamList(JulyS[Julypt-2].objlist),
				0, JulyS[Julypt-0].namelist)
		}
	case 176:
		//line grammar/java11.y:1225
		{
			JulyVAL.obj = NewJInterfaceMethodDecl(makeFormalParamList(JulyS[Julypt-1].objlist),
				0, nil)
		}
	case 177:
		//line grammar/java11.y:1233
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else if jtyp, ok := JulyS[Julypt-2].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-2].obj)
			} else if jifc, ok := JulyS[Julypt-0].obj.(*JInterfaceMethodDecl); !ok {
				ReportCastError("JInterfaceMethodDecl", JulyS[Julypt-0].obj)
			} else {
				jifc.SetModifiers(jmod)
				jifc.SetTypeParameters(JulyS[Julypt-3].objlist)
				jifc.SetType(jtyp)
				jifc.SetName(JulyS[Julypt-1].str)

				JulyVAL.obj = jifc
			}
		}
	case 178:
		//line grammar/java11.y:1250
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else if jifc, ok := JulyS[Julypt-0].obj.(*JInterfaceMethodDecl); !ok {
				ReportCastError("JInterfaceMethodDecl", JulyS[Julypt-0].obj)
			} else {
				jifc.SetModifiers(jmod)
				jifc.SetTypeParameters(JulyS[Julypt-3].objlist)
				jifc.SetType(NewJReferenceType(NewJTypeName("void", true),
					nil, 0))
				jifc.SetName(JulyS[Julypt-1].str)

				JulyVAL.obj = jifc
			}
		}
	case 179:
		//line grammar/java11.y:1266
		{
			if jmod, ok := JulyS[Julypt-3].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-3].obj)
			} else if jifc, ok := JulyS[Julypt-0].obj.(*JInterfaceMethodDecl); !ok {
				ReportCastError("JInterfaceMethodDecl", JulyS[Julypt-0].obj)
			} else {
				jifc.SetModifiers(jmod)
				jifc.SetType(NewJReferenceType(NewJTypeName("void", true),
					nil, 0))
				jifc.SetName(JulyS[Julypt-1].str)

				JulyVAL.obj = jifc
			}
		}
	case 180:
		//line grammar/java11.y:1284
		{
			JulyVAL.objlist = JulyS[Julypt-1].objlist
		}
	case 181:
		//line grammar/java11.y:1286
		{
			JulyVAL.objlist = nil
		}
	case 182:
		//line grammar/java11.y:1291
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 183:
		//line grammar/java11.y:1296
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 184:
		//line grammar/java11.y:1301
		{
			if jmod, ok := JulyS[Julypt-1].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-1].obj)
			} else {
				if fprm, ok := JulyS[Julypt-0].obj.(*JFormalParameter); !ok {
					ReportCastError("JFormalParameter", JulyS[Julypt-0].obj)
				} else {
					fprm.SetModifiers(jmod)
					JulyVAL.obj = fprm
				}
			}
		}
	case 185:
		//line grammar/java11.y:1314
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 186:
		//line grammar/java11.y:1319
		{
			if jtyp, ok := JulyS[Julypt-5].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-5].obj)
			} else {
				JulyVAL.obj = NewJFormalParameter(jtyp, true, JulyS[Julypt-1].str, JulyS[Julypt-0].count)
			}
		}
	case 187:
		//line grammar/java11.y:1327
		{
			if jtyp, ok := JulyS[Julypt-2].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-2].obj)
			} else {
				JulyVAL.obj = NewJFormalParameter(jtyp, false, JulyS[Julypt-1].str, JulyS[Julypt-0].count)
			}
		}
	case 188:
		//line grammar/java11.y:1335
		{
			if jtyp, ok := JulyS[Julypt-4].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-4].obj)
			} else {
				JulyVAL.obj = NewJFormalParameter(jtyp, true, JulyS[Julypt-0].str, 0)
			}
		}
	case 189:
		//line grammar/java11.y:1343
		{
			if jtyp, ok := JulyS[Julypt-1].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-1].obj)
			} else {
				JulyVAL.obj = NewJFormalParameter(jtyp, false, JulyS[Julypt-0].str, 0)
			}
		}
	case 190:
		//line grammar/java11.y:1354
		{
			JulyVAL.obj = NewJModifiers(JulyS[Julypt-0].str, nil)
		}
	case 191:
		//line grammar/java11.y:1356
		{
			if jann, ok := JulyS[Julypt-0].obj.(*JAnnotation); !ok {
				ReportCastError("JAnnotation", JulyS[Julypt-0].obj)
			} else {
				jmod := NewJModifiers("", jann)
				JulyVAL.obj = jmod
			}
		}
	case 192:
		//line grammar/java11.y:1365
		{
			if jmod, ok := JulyS[Julypt-1].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-1].obj)
			} else {
				jmod.AddModifier(JulyS[Julypt-0].str)
				JulyVAL.obj = jmod
			}
		}
	case 193:
		//line grammar/java11.y:1374
		{
			if jmod, ok := JulyS[Julypt-1].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-1].obj)
			} else {
				if jann, ok := JulyS[Julypt-0].obj.(*JAnnotation); !ok {
					ReportCastError("JAnnotation", JulyS[Julypt-0].obj)
				} else {
					jmod.AddAnnotation(jann)
					JulyVAL.obj = jmod
				}
			}
		}
	case 194:
		//line grammar/java11.y:1390
		{
			JulyVAL.obj = &tmpVariableId{name: JulyS[Julypt-1].str, dims: JulyS[Julypt-0].count}
		}
	case 195:
		//line grammar/java11.y:1392
		{
			JulyVAL.obj = &tmpVariableId{name: JulyS[Julypt-0].str, dims: 0}
		}
	case 196:
		//line grammar/java11.y:1397
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 197:
		//line grammar/java11.y:1402
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 198:
		//line grammar/java11.y:1407
		{
			if init, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJVariableDecl(JulyS[Julypt-3].str, JulyS[Julypt-2].count, init)
			}
		}
	case 199:
		//line grammar/java11.y:1415
		{
			JulyVAL.obj = NewJVariableDecl(JulyS[Julypt-1].str, JulyS[Julypt-0].count, nil)
		}
	case 200:
		//line grammar/java11.y:1417
		{
			if init, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJVariableDecl(JulyS[Julypt-2].str, 0, init)
			}
		}
	case 201:
		//line grammar/java11.y:1425
		{
			JulyVAL.obj = NewJVariableDecl(JulyS[Julypt-0].str, 0, nil)
		}
	case 202:
		//line grammar/java11.y:1430
		{
			JulyVAL.obj = NewJVariableInit(nil, JulyS[Julypt-0].varlist)
		}
	case 203:
		//line grammar/java11.y:1434
		{
			JulyVAL.obj = NewJVariableInit(JulyS[Julypt-0].obj, nil)
		}
	case 204:
		//line grammar/java11.y:1441
		{
			if init, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.varlist = make([]*JVariableInit, 1)
				JulyVAL.varlist[0] = init
			}
		}
	case 205:
		//line grammar/java11.y:1450
		{
			if init, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.varlist = append(JulyS[Julypt-2].varlist, init)
			}
		}
	case 206:
		//line grammar/java11.y:1461
		{
			JulyVAL.varlist = JulyS[Julypt-2].varlist
		}
	case 207:
		//line grammar/java11.y:1463
		{
			JulyVAL.varlist = JulyS[Julypt-1].varlist
		}
	case 208:
		//line grammar/java11.y:1465
		{
			JulyVAL.varlist = make([]*JVariableInit, 0)
		}
	case 209:
		//line grammar/java11.y:1470
		{
			JulyVAL.obj = NewJBlock(JulyS[Julypt-1].objlist)
		}
	case 210:
		//line grammar/java11.y:1475
		{
			JulyVAL.objlist = nil
		}
	case 211:
		//line grammar/java11.y:1477
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 212:
		//line grammar/java11.y:1482
		{
			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
		}
	case 213:
		//line grammar/java11.y:1487
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 214:
		//line grammar/java11.y:1489
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 215:
		//line grammar/java11.y:1491
		{
			if JulyS[Julypt-0].obj == nil {
				panic("Found nil block statement")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 216:
		//line grammar/java11.y:1502
		{
			if jmod, ok := JulyS[Julypt-3].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-3].obj)
			} else {
				if jtyp, ok := JulyS[Julypt-2].obj.(*JReferenceType); !ok {
					ReportCastError("JReferenceType", JulyS[Julypt-2].obj)
				} else {
					JulyVAL.obj = NewJLocalVariableDecl(jmod, jtyp,
						makeVarDeclList(JulyS[Julypt-1].objlist))
				}
			}
		}
	case 217:
		//line grammar/java11.y:1515
		{
			if jtyp, ok := JulyS[Julypt-2].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-2].obj)
			} else {
				JulyVAL.obj = NewJLocalVariableDecl(nil, jtyp,
					makeVarDeclList(JulyS[Julypt-1].objlist))
			}
		}
	case 218:
		//line grammar/java11.y:1527
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = jblk
			}
		}
	case 219:
		//line grammar/java11.y:1535
		{
			JulyVAL.obj = NewJEmpty()
		}
	case 220:
		//line grammar/java11.y:1537
		{
			JulyVAL.obj = NewJLabeledStatement(JulyS[Julypt-2].str, JulyS[Julypt-0].obj)
		}
	case 221:
		//line grammar/java11.y:1539
		{
			JulyVAL.obj = NewJSimpleStatement(nil, JulyS[Julypt-1].obj)
		}
	case 222:
		//line grammar/java11.y:1543
		{
			JulyVAL.obj = NewJIfElseStmt(JulyS[Julypt-4].obj, JulyS[Julypt-2].obj, JulyS[Julypt-0].obj)
		}
	case 223:
		//line grammar/java11.y:1547
		{
			JulyVAL.obj = NewJIfElseStmt(JulyS[Julypt-2].obj, JulyS[Julypt-0].obj, nil)
		}
	case 224:
		//line grammar/java11.y:1551
		{
			JulyVAL.obj = NewJUnimplemented("Statement#6")
		}
	case 225:
		//line grammar/java11.y:1553
		{
			JulyVAL.obj = NewJUnimplemented("Statement#7")
		}
	case 226:
		//line grammar/java11.y:1555
		{
			JulyVAL.obj = NewJSwitch(JulyS[Julypt-4].obj, JulyS[Julypt-1].objlist)
		}
	case 227:
		//line grammar/java11.y:1557
		{
			JulyVAL.obj = NewJSwitch(JulyS[Julypt-3].obj, nil)
		}
	case 228:
		//line grammar/java11.y:1559
		{
			JulyVAL.obj = NewJWhile(JulyS[Julypt-2].obj, JulyS[Julypt-0].obj, false)
		}
	case 229:
		//line grammar/java11.y:1563
		{
			JulyVAL.obj = NewJWhile(JulyS[Julypt-2].obj, JulyS[Julypt-5].obj, true)
		}
	case 230:
		//line grammar/java11.y:1567
		{
			if jfor, ok := JulyS[Julypt-2].obj.(*JForColon); ok {
				jfor.SetBody(JulyS[Julypt-0].obj)
				JulyVAL.obj = jfor
			} else if jforexp, ok := JulyS[Julypt-2].obj.(*JForExpr); ok {
				jforexp.SetBody(JulyS[Julypt-0].obj)
				JulyVAL.obj = jforexp
			} else if jforvar, ok := JulyS[Julypt-2].obj.(*JForVar); ok {
				jforvar.SetBody(JulyS[Julypt-0].obj)
				JulyVAL.obj = jforvar
			} else {
				ReportCastError("JForVar", JulyS[Julypt-2].obj)
			}
		}
	case 231:
		//line grammar/java11.y:1582
		{
			JulyVAL.obj = NewJJumpToLabel(JulyS[Julypt-2].token, JulyS[Julypt-1].str)
		}
	case 232:
		//line grammar/java11.y:1584
		{
			JulyVAL.obj = NewJSimpleStatement(NewJKeyword(JulyS[Julypt-1].token, JulyS[Julypt-1].str), nil)
		}
	case 233:
		//line grammar/java11.y:1586
		{
			JulyVAL.obj = NewJJumpToLabel(JulyS[Julypt-2].token, JulyS[Julypt-1].str)
		}
	case 234:
		//line grammar/java11.y:1588
		{
			JulyVAL.obj = NewJSimpleStatement(NewJKeyword(JulyS[Julypt-1].token, JulyS[Julypt-1].str), nil)
		}
	case 235:
		//line grammar/java11.y:1590
		{
			JulyVAL.obj = NewJSimpleStatement(NewJKeyword(JulyS[Julypt-2].token, JulyS[Julypt-2].str), JulyS[Julypt-1].obj)
		}
	case 236:
		//line grammar/java11.y:1592
		{
			JulyVAL.obj = NewJSimpleStatement(NewJKeyword(JulyS[Julypt-1].token, JulyS[Julypt-1].str), nil)
		}
	case 237:
		//line grammar/java11.y:1594
		{
			JulyVAL.obj = NewJSimpleStatement(NewJKeyword(JulyS[Julypt-2].token, JulyS[Julypt-2].str), JulyS[Julypt-1].obj)
		}
	case 238:
		//line grammar/java11.y:1596
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJSynchronized(JulyS[Julypt-2].obj, jblk)
			}
		}
	case 239:
		//line grammar/java11.y:1604
		{
			if jblk, ok := JulyS[Julypt-1].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-1].obj)
			} else {
				JulyVAL.obj = NewJTry(jblk, JulyS[Julypt-0].objlist, nil)
			}
		}
	case 240:
		//line grammar/java11.y:1612
		{
			if jblk, ok := JulyS[Julypt-2].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-2].obj)
			} else if jfin, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJTry(jblk, JulyS[Julypt-1].objlist, jfin)
			}
		}
	case 241:
		//line grammar/java11.y:1622
		{
			if jblk, ok := JulyS[Julypt-1].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-1].obj)
			} else if jfin, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJTry(jblk, nil, jfin)
			}
		}
	case 242:
		//line grammar/java11.y:1632
		{
			JulyVAL.obj = NewJUnimplemented("Statement#24")
		}
	case 243:
		//line grammar/java11.y:1634
		{
			JulyVAL.obj = NewJUnimplemented("Statement#25")
		}
	case 244:
		//line grammar/java11.y:1636
		{
			JulyVAL.obj = NewJUnimplemented("Statement#26")
		}
	case 245:
		//line grammar/java11.y:1638
		{
			JulyVAL.obj = NewJUnimplemented("Statement#27")
		}
	case 246:
		//line grammar/java11.y:1643
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 247:
		//line grammar/java11.y:1648
		{
			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
		}
	case 248:
		//line grammar/java11.y:1653
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else {
				if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
					ReportCastError("JBlock", JulyS[Julypt-0].obj)
				} else {
					JulyVAL.obj = NewJCatch(jmod, JulyS[Julypt-3].namelist, JulyS[Julypt-2].str, jblk)
				}
			}
		}
	case 249:
		//line grammar/java11.y:1665
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJCatch(nil, JulyS[Julypt-3].namelist, JulyS[Julypt-2].str, jblk)
			}
		}
	case 250:
		//line grammar/java11.y:1676
		{
			JulyVAL.namelist = make([]*JTypeName, 1)
			JulyVAL.namelist[0] = JulyS[Julypt-0].name
		}
	case 251:
		//line grammar/java11.y:1681
		{
			JulyVAL.namelist = append(JulyS[Julypt-2].namelist, JulyS[Julypt-0].name)
		}
	case 252:
		//line grammar/java11.y:1686
		{
			if jblk, ok := JulyS[Julypt-0].obj.(*JBlock); !ok {
				ReportCastError("JBlock", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = jblk
			}
		}
	case 253:
		//line grammar/java11.y:1697
		{
			JulyVAL.obj = NewJUnimplemented("ResourceSpecification#0")
		}
	case 254:
		//line grammar/java11.y:1699
		{
			JulyVAL.obj = NewJUnimplemented("ResourceSpecification#1")
		}
	case 255:
		//line grammar/java11.y:1704
		{
			JulyVAL.obj = NewJUnimplemented("Resources#0")
		}
	case 256:
		//line grammar/java11.y:1706
		{
			JulyVAL.obj = NewJUnimplemented("Resources#1")
		}
	case 257:
		//line grammar/java11.y:1711
		{
			JulyVAL.obj = NewJUnimplemented("Resource#0")
		}
	case 258:
		//line grammar/java11.y:1713
		{
			JulyVAL.obj = NewJUnimplemented("Resource#1")
		}
	case 259:
		//line grammar/java11.y:1718
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 260:
		//line grammar/java11.y:1723
		{
			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
		}
	case 261:
		//line grammar/java11.y:1728
		{
			JulyVAL.obj = NewJSwitchGroup(JulyS[Julypt-1].objlist, JulyS[Julypt-0].objlist)
		}
	case 262:
		//line grammar/java11.y:1733
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 263:
		//line grammar/java11.y:1738
		{
			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
		}
	case 264:
		//line grammar/java11.y:1743
		{
			JulyVAL.obj = NewJSwitchLabel("", JulyS[Julypt-1].obj, false)
		}
	case 265:
		//line grammar/java11.y:1745
		{
			JulyVAL.obj = NewJSwitchLabel(JulyS[Julypt-2].str, nil, false)
		}
	case 266:
		//line grammar/java11.y:1747
		{
			JulyVAL.obj = NewJSwitchLabel("", nil, true)
		}
	case 267:
		//line grammar/java11.y:1752
		{
			JulyVAL.namelist = make([]*JTypeName, 1)
			JulyVAL.namelist[0] = JulyS[Julypt-0].name
		}
	case 268:
		//line grammar/java11.y:1757
		{
			JulyVAL.namelist = append(JulyS[Julypt-2].namelist, JulyS[Julypt-0].name)
		}
	case 269:
		//line grammar/java11.y:1762
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 270:
		//line grammar/java11.y:1764
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 271:
		//line grammar/java11.y:1766
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 272:
		//line grammar/java11.y:1768
		{
			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 273:
		//line grammar/java11.y:1773
		{
			if jmod, ok := JulyS[Julypt-4].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-4].obj)
			} else if jtyp, ok := JulyS[Julypt-3].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-3].obj)
			} else if jvid, ok := JulyS[Julypt-2].obj.(*tmpVariableId); !ok {
				ReportCastError("tmpVariableId", JulyS[Julypt-2].obj)
			} else {
				JulyVAL.obj = NewJForColon(jmod, jtyp, jvid.name, jvid.dims, JulyS[Julypt-0].obj)
			}
		}
	case 274:
		//line grammar/java11.y:1785
		{
			if jtyp, ok := JulyS[Julypt-3].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-3].obj)
			} else if jvid, ok := JulyS[Julypt-2].obj.(*tmpVariableId); !ok {
				ReportCastError("tmpVariableId", JulyS[Julypt-2].obj)
			} else {
				JulyVAL.obj = NewJForColon(nil, jtyp, jvid.name, jvid.dims, JulyS[Julypt-0].obj)
			}
		}
	case 275:
		//line grammar/java11.y:1798
		{
			JulyVAL.obj = NewJForExpr(nil, JulyS[Julypt-2].obj, JulyS[Julypt-0].objlist)
		}
	case 276:
		//line grammar/java11.y:1802
		{
			JulyVAL.obj = NewJForExpr(nil, JulyS[Julypt-1].obj, nil)
		}
	case 277:
		//line grammar/java11.y:1806
		{
			JulyVAL.obj = NewJForExpr(nil, nil, JulyS[Julypt-0].objlist)
		}
	case 278:
		//line grammar/java11.y:1810
		{
			JulyVAL.obj = NewJForExpr(nil, nil, nil)
		}
	case 279:
		//line grammar/java11.y:1817
		{
			JulyVAL.obj = NewJForExpr(JulyS[Julypt-4].objlist, JulyS[Julypt-2].obj, JulyS[Julypt-0].objlist)
		}
	case 280:
		//line grammar/java11.y:1821
		{
			JulyVAL.obj = NewJForExpr(JulyS[Julypt-3].objlist, JulyS[Julypt-1].obj, nil)
		}
	case 281:
		//line grammar/java11.y:1825
		{
			JulyVAL.obj = NewJForExpr(JulyS[Julypt-3].objlist, nil, JulyS[Julypt-0].objlist)
		}
	case 282:
		//line grammar/java11.y:1829
		{
			JulyVAL.obj = NewJForExpr(JulyS[Julypt-2].objlist, nil, nil)
		}
	case 283:
		//line grammar/java11.y:1836
		{
			if jfor, ok := JulyS[Julypt-4].obj.(*JForVar); !ok {
				ReportCastError("JForVar", JulyS[Julypt-4].obj)
			} else {
				if JulyS[Julypt-2].obj != nil {
					jfor.SetExpr(JulyS[Julypt-2].obj)
				}

				if JulyS[Julypt-0].objlist != nil {
					jfor.SetIncr(JulyS[Julypt-0].objlist)
				}

				JulyVAL.obj = jfor
			}
		}
	case 284:
		//line grammar/java11.y:1852
		{
			if jfor, ok := JulyS[Julypt-3].obj.(*JForVar); !ok {
				ReportCastError("JForVar", JulyS[Julypt-3].obj)
			} else {
				if JulyS[Julypt-1].obj != nil {
					jfor.SetExpr(JulyS[Julypt-1].obj)
				}

				JulyVAL.obj = jfor
			}
		}
	case 285:
		//line grammar/java11.y:1864
		{
			if jfor, ok := JulyS[Julypt-3].obj.(*JForVar); !ok {
				ReportCastError("JForVar", JulyS[Julypt-3].obj)
			} else {
				if JulyS[Julypt-0].objlist != nil {
					jfor.SetIncr(JulyS[Julypt-0].objlist)
				}

				JulyVAL.obj = jfor
			}
		}
	case 286:
		//line grammar/java11.y:1876
		{
			if jfor, ok := JulyS[Julypt-2].obj.(*JForVar); !ok {
				ReportCastError("JForVar", JulyS[Julypt-2].obj)
			} else {
				JulyVAL.obj = jfor
			}
		}
	case 287:
		//line grammar/java11.y:1887
		{
			if jfor, ok := JulyS[Julypt-4].obj.(*JForVar); !ok {
				ReportCastError("JForVar", JulyS[Julypt-4].obj)
			} else if init, ok := JulyS[Julypt-2].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-3].obj)
			} else {
				jfor.SetInit(init)
				jfor.SetDecl(JulyS[Julypt-0].obj)
				JulyVAL.obj = jfor
			}
		}
	case 288:
		//line grammar/java11.y:1899
		{
			if jfor, ok := JulyS[Julypt-2].obj.(*JForVar); !ok {
				ReportCastError("JForVar", JulyS[Julypt-2].obj)
			} else if init, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-1].obj)
			} else {
				jfor.SetInit(init)
				JulyVAL.obj = jfor
			}
		}
	case 289:
		//line grammar/java11.y:1910
		{
			if jfor, ok := JulyS[Julypt-2].obj.(*JForVar); !ok {
				ReportCastError("JForVar", JulyS[Julypt-2].obj)
			} else {
				jfor.SetDecl(JulyS[Julypt-0].obj)
				JulyVAL.obj = jfor
			}
		}
	case 290:
		//line grammar/java11.y:1919
		{
			if jfor, ok := JulyS[Julypt-0].obj.(*JForVar); !ok {
				ReportCastError("JForVar", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = jfor
			}
		}
	case 291:
		//line grammar/java11.y:1930
		{
			if jmod, ok := JulyS[Julypt-2].obj.(*JModifiers); !ok {
				ReportCastError("JModifiers", JulyS[Julypt-2].obj)
			} else if jtyp, ok := JulyS[Julypt-1].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-1].obj)
			} else if jvid, ok := JulyS[Julypt-0].obj.(*tmpVariableId); !ok {
				ReportCastError("tmpVariableId", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJForVar(jmod, jtyp, jvid.name, jvid.dims)
			}
		}
	case 292:
		//line grammar/java11.y:1942
		{
			if jtyp, ok := JulyS[Julypt-1].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-1].obj)
			} else if jvid, ok := JulyS[Julypt-0].obj.(*tmpVariableId); !ok {
				ReportCastError("tmpVariableId", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJForVar(nil, jtyp, jvid.name, jvid.dims)
			}
		}
	case 293:
		//line grammar/java11.y:1955
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 294:
		//line grammar/java11.y:1960
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 295:
		//line grammar/java11.y:1965
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 296:
		//line grammar/java11.y:1970
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 297:
		//line grammar/java11.y:1975
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("ConditionalExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 298:
		//line grammar/java11.y:1983
		{
			JulyVAL.obj = NewJAssignmentExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 299:
		//line grammar/java11.y:1988
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 300:
		//line grammar/java11.y:1990
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 301:
		//line grammar/java11.y:1992
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 302:
		//line grammar/java11.y:1994
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 303:
		//line grammar/java11.y:1996
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 304:
		//line grammar/java11.y:1998
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 305:
		//line grammar/java11.y:2000
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 306:
		//line grammar/java11.y:2002
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 307:
		//line grammar/java11.y:2004
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 308:
		//line grammar/java11.y:2006
		{
			JulyVAL.str = "<<="
		}
	case 309:
		//line grammar/java11.y:2008
		{
			JulyVAL.str = ">>="
		}
	case 310:
		//line grammar/java11.y:2010
		{
			JulyVAL.str = ">>>="
		}
	case 311:
		//line grammar/java11.y:2015
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("LogicalOrExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 312:
		//line grammar/java11.y:2023
		{
			JulyVAL.obj = NewJConditionalExpr(JulyS[Julypt-4].obj, JulyS[Julypt-2].obj, JulyS[Julypt-0].obj)
		}
	case 313:
		//line grammar/java11.y:2030
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("LogicalAndExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 314:
		//line grammar/java11.y:2038
		{
			JulyVAL.obj = NewJBinaryExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 315:
		//line grammar/java11.y:2045
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 316:
		//line grammar/java11.y:2050
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("BitwiseOrExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 317:
		//line grammar/java11.y:2058
		{
			JulyVAL.obj = NewJBinaryExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 318:
		//line grammar/java11.y:2065
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 319:
		//line grammar/java11.y:2070
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("BitwiseXorExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 320:
		//line grammar/java11.y:2078
		{
			JulyVAL.obj = NewJBinaryExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 321:
		//line grammar/java11.y:2085
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 322:
		//line grammar/java11.y:2090
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("BitwiseAndExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 323:
		//line grammar/java11.y:2098
		{
			JulyVAL.obj = NewJBinaryExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 324:
		//line grammar/java11.y:2105
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 325:
		//line grammar/java11.y:2110
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("EqualityExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 326:
		//line grammar/java11.y:2118
		{
			JulyVAL.obj = NewJBinaryExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 327:
		//line grammar/java11.y:2125
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 328:
		//line grammar/java11.y:2130
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("RelationalExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 329:
		//line grammar/java11.y:2138
		{
			JulyVAL.obj = NewJBinaryExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 330:
		//line grammar/java11.y:2145
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 331:
		//line grammar/java11.y:2147
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 332:
		//line grammar/java11.y:2152
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("AdditiveExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 333:
		//line grammar/java11.y:2160
		{
			JulyVAL.obj = NewJBinaryExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 334:
		//line grammar/java11.y:2164
		{
			if jtyp, ok := JulyS[Julypt-0].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = NewJInstanceOf(JulyS[Julypt-2].obj, jtyp)
			}
		}
	case 335:
		//line grammar/java11.y:2175
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 336:
		//line grammar/java11.y:2177
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 337:
		//line grammar/java11.y:2179
		{
			JulyVAL.str = "<="
		}
	case 338:
		//line grammar/java11.y:2181
		{
			JulyVAL.str = ">="
		}
	case 339:
		//line grammar/java11.y:2183
		{
			JulyVAL.str = "<<"
		}
	case 340:
		//line grammar/java11.y:2185
		{
			JulyVAL.str = ">>"
		}
	case 341:
		//line grammar/java11.y:2187
		{
			JulyVAL.str = ">>>"
		}
	case 342:
		//line grammar/java11.y:2192
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("MultiplicativeExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 343:
		//line grammar/java11.y:2200
		{
			JulyVAL.obj = NewJBinaryExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 344:
		//line grammar/java11.y:2207
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 345:
		//line grammar/java11.y:2209
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 346:
		//line grammar/java11.y:2214
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("CastExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 347:
		//line grammar/java11.y:2222
		{
			JulyVAL.obj = NewJBinaryExpr(JulyS[Julypt-2].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].obj)
		}
	case 348:
		//line grammar/java11.y:2229
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 349:
		//line grammar/java11.y:2231
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 350:
		//line grammar/java11.y:2233
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 351:
		//line grammar/java11.y:2238
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 352:
		//line grammar/java11.y:2240
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 353:
		//line grammar/java11.y:2242
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 354:
		//line grammar/java11.y:2244
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 355:
		//line grammar/java11.y:2246
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 356:
		//line grammar/java11.y:2248
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 357:
		//line grammar/java11.y:2253
		{
			JulyVAL.obj = NewJUnaryExpr(JulyS[Julypt-1].str, JulyS[Julypt-0].obj, true)
		}
	case 358:
		//line grammar/java11.y:2255
		{
			if ref, ok := JulyS[Julypt-2].obj.(*JReferenceType); !ok {
				ReportCastError("JReferenceType", JulyS[Julypt-2].obj)
			} else {
				JulyVAL.obj = NewJCastExpr(ref, JulyS[Julypt-0].obj)
			}
		}
	case 359:
		//line grammar/java11.y:2263
		{
			ref := NewJReferenceType(JulyS[Julypt-3].name, nil, JulyS[Julypt-2].count)
			JulyVAL.obj = NewJCastExpr(ref, JulyS[Julypt-0].obj)
		}
	case 360:
		//line grammar/java11.y:2268
		{
			ref := NewJReferenceType(NewJTypeName(JulyS[Julypt-2].str, true), nil, 0)
			JulyVAL.obj = NewJCastExpr(ref, JulyS[Julypt-0].obj)
		}
	case 361:
		//line grammar/java11.y:2273
		{
			ref := NewJReferenceType(NewJTypeName(JulyS[Julypt-3].str, true), nil, JulyS[Julypt-2].count)
			JulyVAL.obj = NewJCastExpr(ref, JulyS[Julypt-0].obj)
		}
	case 362:
		//line grammar/java11.y:2278
		{
			JulyVAL.obj = NewJUnaryExpr(JulyS[Julypt-0].str, JulyS[Julypt-1].obj, false)
		}
	case 363:
		//line grammar/java11.y:2280
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("PrimaryExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 364:
		//line grammar/java11.y:2291
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 365:
		//line grammar/java11.y:2293
		{
			JulyVAL.str = JulyS[Julypt-0].str
		}
	case 366:
		//line grammar/java11.y:2298
		{
			JulyVAL.obj = NewJReferenceType(JulyS[Julypt-0].name, nil, 0)
		}
	case 367:
		//line grammar/java11.y:2300
		{
			JulyVAL.obj = NewJKeyword(JulyS[Julypt-0].token, JulyS[Julypt-0].str)
		}
	case 368:
		//line grammar/java11.y:2302
		{
			JulyVAL.obj = NewJKeyword(JulyS[Julypt-0].token, JulyS[Julypt-0].str)
		}
	case 369:
		//line grammar/java11.y:2304
		{
			JulyVAL.obj = NewJKeyword(JulyS[Julypt-0].token, JulyS[Julypt-0].str)
		}
	case 370:
		//line grammar/java11.y:2306
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("PlainNewAllocationExpression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 371:
		//line grammar/java11.y:2314
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("PlainNewAllocationExpression cannot be nil")
			}

			JulyVAL.obj = NewJNameDotObject(JulyS[Julypt-2].name, JulyS[Julypt-0].obj)
		}
	case 372:
		//line grammar/java11.y:2322
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("ComplexPrimaryNoParenthesis cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-0].obj
		}
	case 373:
		//line grammar/java11.y:2330
		{
			if JulyS[Julypt-1].obj == nil {
				ReportError("Expression cannot be nil")
			}

			JulyVAL.obj = JulyS[Julypt-1].obj
		}
	case 374:
		//line grammar/java11.y:2341
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("ArrayAllocationExpression cannot be nil")
			} else if aae, ok := JulyS[Julypt-0].obj.(*JArrayAlloc); !ok {
				ReportCastError("JArrayAlloc", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = aae
			}
		}
	case 375:
		//line grammar/java11.y:2351
		{
			if JulyS[Julypt-2].obj == nil {
				ReportError("ArrayAllocationExpression cannot be nil")
			} else if aae, ok := JulyS[Julypt-2].obj.(*JArrayAlloc); !ok {
				ReportCastError("JArrayAlloc", JulyS[Julypt-2].obj)
			} else {
				JulyVAL.obj = aae
			}
		}
	case 376:
		//line grammar/java11.y:2361
		{
			if JulyS[Julypt-3].obj == nil {
				ReportError("ArrayAllocationExpression cannot be nil")
			} else if aae, ok := JulyS[Julypt-3].obj.(*JArrayAlloc); !ok {
				ReportCastError("JArrayAlloc", JulyS[Julypt-3].obj)
			} else {
				aae.SetInitializers(JulyS[Julypt-1].varlist)
				JulyVAL.obj = aae
			}
		}
	case 377:
		//line grammar/java11.y:2372
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("ClassAllocationExpression cannot be nil")
			} else if cae, ok := JulyS[Julypt-0].obj.(*JClassAllocationExpr); !ok {
				ReportCastError("JClassAllocationExpr", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.obj = cae
			}
		}
	case 378:
		//line grammar/java11.y:2382
		{
			if JulyS[Julypt-1].obj == nil {
				ReportError("ClassAllocationExpression cannot be nil")
			} else if cae, ok := JulyS[Julypt-1].obj.(*JClassAllocationExpr); !ok {
				ReportCastError("JClassAllocationExpr", JulyS[Julypt-1].obj)
			} else {
				cae.SetBody(JulyS[Julypt-0].objlist)
				JulyVAL.obj = cae
			}
		}
	case 379:
		//line grammar/java11.y:2396
		{
			JulyVAL.obj = NewJLiteral(JulyS[Julypt-0].str)
		}
	case 380:
		//line grammar/java11.y:2398
		{
			JulyVAL.obj = NewJKeyword(JulyS[Julypt-0].token, JulyS[Julypt-0].str)
		}
	case 381:
		//line grammar/java11.y:2400
		{
			JulyVAL.obj = NewJArrayReference(JulyS[Julypt-3].name, nil, JulyS[Julypt-1].obj)
		}
	case 382:
		//line grammar/java11.y:2402
		{
			JulyVAL.obj = NewJArrayReference(nil, NewJParens(JulyS[Julypt-4].obj), JulyS[Julypt-1].obj)
		}
	case 383:
		//line grammar/java11.y:2404
		{
			JulyVAL.obj = NewJArrayReference(nil, JulyS[Julypt-3].obj, JulyS[Julypt-1].obj)
		}
	case 384:
		//line grammar/java11.y:2406
		{
			JulyVAL.obj = NewJObjectDotName(JulyS[Julypt-2].obj, NewJTypeName(JulyS[Julypt-0].str, false))
		}
	case 385:
		//line grammar/java11.y:2408
		{
			JulyVAL.obj = NewJUnimplemented("ComplexPrimaryNoParenthesis#6")
		}
	case 386:
		//line grammar/java11.y:2410
		{
			JulyVAL.obj = NewJNameDotObject(JulyS[Julypt-2].name, NewJKeyword(JulyS[Julypt-0].token, JulyS[Julypt-0].str))
		}
	case 387:
		//line grammar/java11.y:2412
		{
			JulyVAL.obj = NewJNameDotObject(JulyS[Julypt-2].name, NewJKeyword(JulyS[Julypt-0].token, JulyS[Julypt-0].str))
		}
	case 388:
		//line grammar/java11.y:2414
		{
			JulyVAL.obj = NewJNameDotObject(NewJTypeName(JulyS[Julypt-2].str, true),
				NewJKeyword(JulyS[Julypt-0].token, JulyS[Julypt-0].str))
		}
	case 389:
		//line grammar/java11.y:2419
		{
			JulyVAL.obj = NewJUnimplemented("ComplexPrimaryNoParenthesis#10")
		}
	case 390:
		//line grammar/java11.y:2421
		{
			JulyVAL.obj = NewJMethodAccessComplex(JulyS[Julypt-3].obj, JulyS[Julypt-1].str, JulyS[Julypt-0].objlist)
		}
	case 391:
		//line grammar/java11.y:2423
		{
			JulyVAL.obj = NewJMethodAccessKeyword(JulyS[Julypt-1].token, JulyS[Julypt-1].str, JulyS[Julypt-0].objlist)
		}
	case 392:
		//line grammar/java11.y:2425
		{
			JulyVAL.obj = NewJMethodAccessKeyword(JulyS[Julypt-1].token, JulyS[Julypt-1].str, JulyS[Julypt-0].objlist)
		}
	case 393:
		//line grammar/java11.y:2427
		{
			// is "null(arg1, arg2, ...)" really valid?
			JulyVAL.obj = NewJMethodAccessKeyword(JulyS[Julypt-1].token, JulyS[Julypt-1].str, JulyS[Julypt-0].objlist)
		}
	case 394:
		//line grammar/java11.y:2432
		{
			JulyVAL.obj = NewJMethodAccessName(JulyS[Julypt-1].name, JulyS[Julypt-0].objlist)
		}
	case 395:
		//line grammar/java11.y:2437
		{
			JulyVAL.objlist = JulyS[Julypt-1].objlist
		}
	case 396:
		//line grammar/java11.y:2439
		{
			JulyVAL.objlist = nil
		}
	case 397:
		//line grammar/java11.y:2444
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 398:
		//line grammar/java11.y:2449
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 399:
		//line grammar/java11.y:2454
		{
			if vin, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.varlist = make([]*JVariableInit, 1)
				JulyVAL.varlist[0] = vin
			}
		}
	case 400:
		//line grammar/java11.y:2463
		{
			if vin, ok := JulyS[Julypt-0].obj.(*JVariableInit); !ok {
				ReportCastError("JVariableInit", JulyS[Julypt-0].obj)
			} else {
				JulyVAL.varlist = append(JulyS[Julypt-2].varlist, vin)
			}
		}
	case 401:
		//line grammar/java11.y:2471
		{
			JulyVAL.varlist = JulyS[Julypt-1].varlist
		}
	case 402:
		//line grammar/java11.y:2476
		{
			JulyVAL.obj = NewJClassAllocationExpr(JulyS[Julypt-1].name, nil, JulyS[Julypt-0].objlist)
		}
	case 403:
		//line grammar/java11.y:2478
		{
			JulyVAL.obj = NewJClassAllocationExpr(JulyS[Julypt-2].name, JulyS[Julypt-1].objlist, JulyS[Julypt-0].objlist)
		}
	case 404:
		//line grammar/java11.y:2483
		{
			JulyVAL.obj = NewJArrayAlloc(JulyS[Julypt-2].name, JulyS[Julypt-1].objlist, JulyS[Julypt-0].count)
		}
	case 405:
		//line grammar/java11.y:2485
		{
			JulyVAL.obj = NewJArrayAlloc(JulyS[Julypt-1].name, JulyS[Julypt-0].objlist, 0)
		}
	case 406:
		//line grammar/java11.y:2487
		{
			JulyVAL.obj = NewJArrayAlloc(JulyS[Julypt-1].name, nil, JulyS[Julypt-0].count)
		}
	case 407:
		//line grammar/java11.y:2492
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 408:
		//line grammar/java11.y:2497
		{
			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
		}
	case 409:
		//line grammar/java11.y:2502
		{
			JulyVAL.obj = JulyS[Julypt-1].obj
		}
	case 410:
		//line grammar/java11.y:2507
		{
			JulyVAL.obj = NewJEnumBody(JulyS[Julypt-3].objlist, JulyS[Julypt-1].objlist)
		}
	case 411:
		//line grammar/java11.y:2509
		{
			JulyVAL.obj = NewJEnumBody(JulyS[Julypt-2].objlist, nil)
		}
	case 412:
		//line grammar/java11.y:2511
		{
			JulyVAL.obj = NewJEnumBody(JulyS[Julypt-2].objlist, JulyS[Julypt-1].objlist)
		}
	case 413:
		//line grammar/java11.y:2513
		{
			JulyVAL.obj = NewJEnumBody(JulyS[Julypt-1].objlist, nil)
		}
	case 414:
		//line grammar/java11.y:2515
		{
			JulyVAL.obj = NewJEnumBody(nil, JulyS[Julypt-1].objlist)
		}
	case 415:
		//line grammar/java11.y:2517
		{
			JulyVAL.obj = NewJEnumBody(nil, nil)
		}
	case 416:
		//line grammar/java11.y:2519
		{
			JulyVAL.obj = NewJEnumBody(nil, JulyS[Julypt-1].objlist)
		}
	case 417:
		//line grammar/java11.y:2521
		{
			JulyVAL.obj = NewJEnumBody(nil, nil)
		}
	case 418:
		//line grammar/java11.y:2526
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 419:
		//line grammar/java11.y:2531
		{
			JulyVAL.objlist = append(JulyS[Julypt-2].objlist, JulyS[Julypt-0].obj)
		}
	case 420:
		//line grammar/java11.y:2536
		{
			JulyVAL.obj = NewJEnumConstant(JulyS[Julypt-3].objlist, JulyS[Julypt-2].str, JulyS[Julypt-1].objlist,
				JulyS[Julypt-0].objlist)
		}
	case 421:
		//line grammar/java11.y:2541
		{
			JulyVAL.obj = NewJEnumConstant(JulyS[Julypt-2].objlist, JulyS[Julypt-1].str, JulyS[Julypt-0].objlist, nil)
		}
	case 422:
		//line grammar/java11.y:2545
		{
			JulyVAL.obj = NewJEnumConstant(JulyS[Julypt-2].objlist, JulyS[Julypt-1].str, nil, JulyS[Julypt-0].objlist)
		}
	case 423:
		//line grammar/java11.y:2549
		{
			JulyVAL.obj = NewJEnumConstant(JulyS[Julypt-1].objlist, JulyS[Julypt-0].str, nil, nil)
		}
	case 424:
		//line grammar/java11.y:2553
		{
			JulyVAL.obj = NewJEnumConstant(nil, JulyS[Julypt-2].str, JulyS[Julypt-1].objlist, JulyS[Julypt-0].objlist)
		}
	case 425:
		//line grammar/java11.y:2557
		{
			JulyVAL.obj = NewJEnumConstant(nil, JulyS[Julypt-1].str, JulyS[Julypt-0].objlist, nil)
		}
	case 426:
		//line grammar/java11.y:2561
		{
			JulyVAL.obj = NewJEnumConstant(nil, JulyS[Julypt-1].str, nil, JulyS[Julypt-0].objlist)
		}
	case 427:
		//line grammar/java11.y:2565
		{
			JulyVAL.obj = NewJEnumConstant(nil, JulyS[Julypt-0].str, nil, nil)
		}
	case 428:
		//line grammar/java11.y:2572
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("Found empty class body entry")
			}

			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 429:
		//line grammar/java11.y:2581
		{
			if JulyS[Julypt-0].obj == nil {
				ReportError("Found empty class body entry")
			}

			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
		}
	case 430:
		//line grammar/java11.y:2592
		{
			JulyVAL.objlist = JulyS[Julypt-0].objlist
		}
	case 431:
		//line grammar/java11.y:2594
		{
			JulyVAL.objlist = nil
		}
	case 432:
		//line grammar/java11.y:2599
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationTypeBody#0")
		}
	case 433:
		//line grammar/java11.y:2601
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationTypeBody#1")
		}
	case 434:
		//line grammar/java11.y:2606
		{
			JulyVAL.objlist = make([]JObject, 1)
			JulyVAL.objlist[0] = JulyS[Julypt-0].obj
		}
	case 435:
		//line grammar/java11.y:2611
		{
			JulyVAL.objlist = append(JulyS[Julypt-1].objlist, JulyS[Julypt-0].obj)
		}
	case 436:
		//line grammar/java11.y:2616
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationTypeElementDeclaration#0")
		}
	case 437:
		//line grammar/java11.y:2618
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationTypeElementDeclaration#1")
		}
	case 438:
		//line grammar/java11.y:2620
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationTypeElementDeclaration#2")
		}
	case 439:
		//line grammar/java11.y:2622
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationTypeElementDeclaration#3")
		}
	case 440:
		//line grammar/java11.y:2627
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationMethodRest#0")
		}
	case 441:
		//line grammar/java11.y:2629
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationMethodRest#1")
		}
	case 442:
		//line grammar/java11.y:2631
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationMethodRest#2")
		}
	case 443:
		//line grammar/java11.y:2633
		{
			JulyVAL.obj = NewJUnimplemented("AnnotationMethodRest#3")
		}
	}
	goto Julystack /* stack new state and value */
}
